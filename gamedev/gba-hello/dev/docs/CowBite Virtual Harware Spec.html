From: <Saved by Blink>
Snapshot-Content-Location: https://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm
Subject: CowBite Virtual Harware Spec
Date: Fri, 4 Jun 2021 17:16:36 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--zeeJfYrDhIOf5DTTzQx4dFZQdEPfC9gTLoRmLB1V2w----"


------MultipartBoundary--zeeJfYrDhIOf5DTTzQx4dFZQdEPfC9gTLoRmLB1V2w----
Content-Type: text/html
Content-ID: <frame-578B3CA8590119E8DF6C5890A5D12E89@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: https://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN"><html><head><meta http-equ=
iv=3D"Content-Type" content=3D"text/html; charset=3Dwindows-1252">
	<meta name=3D"GENERATOR" content=3D"Visual Page 1.0 for Windows">
=09
	<title>CowBite Virtual Harware Spec</title>
</head>

<body bgcolor=3D"#FFFFFF">

<h2 align=3D"CENTER"><br>
<br>
CowBite Virtual Hardware Specifications</h2>
<p align=3D"CENTER"><font size=3D"2">Unofficial documentation for the CowBi=
te GBA emulator<br>
by </font><a href=3D"mailto:SorcererXIII@yahoo.com"><font size=3D"2">Tom Ha=
pp</font></a></p>
<p align=3D"CENTER"><font size=3D"2">Sun Aug 4 17:21:40 2002<br>
<br>
The most recent version is kept at <br>
</font><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm"><=
font size=3D"2">http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm</fon=
t></a><font size=3D"2"> <br>
and </font><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.zi=
p"><font size=3D"2">http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.zip<=
/font></a><font size=3D"2">.</font>


</p><blockquote>
	<p align=3D"CENTER">Available <br>
	<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpecFrame.htm" ta=
rget=3D"_parent"><b>With Frames</b></a> and
	<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm" target=
=3D"_parent"><b>Without Frames</b></a></p>

</blockquote>

<h2><a name=3D"Table of Contents"></a>Table of Contents<br>

<hr align=3D"CENTER">
</h2>
<p>1. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Int=
roduction">Introduction</a><br>
2. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#CPU">C=
PU</a><br>
3. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Memory=
%20Map">Memory</a><br>
4. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Graphi=
cs%20Hardware%20Overview">Graphics Hardware
Overview</a><br>
5. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Backgr=
ounds">Backgrounds</a><br>
6. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#OAM%20=
(sprites)">OAM/Sprites</a><br>
7. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Window=
ing">Windowing</a><br>
8. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Hardwa=
re%20Interrupts">Hardware Interrupts</a><br>
9. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#BIOS%2=
0(Software%20Interrupts)">BIOS</a><br>
10. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Memor=
y-Mapped%20Hardware%20Registers">Memory-Mapped
Hardware Registers</a>

</p><ul>
	<li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Grap=
hics%20Hardware%20Registers">Graphics Hardware
	Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Banked%20registers">Background Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Background%20Rotation/Scaling%20Regi">Background
	Scaling/Rotation Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Windowing%20Registers">Windowing Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Effects%20Registers">Effects Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Sound%20Controls">Sound Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#DMA%20Source%20Registers">DMA Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Timer%20registers">Timer Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Serial%20Communication%20Registers">Serial Communication
	Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Keypad%20input%20and%20control%20registe">Keyboard
	Registers</a>
	</li><li><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Interrupt%20Registers">Interrupt Registers</a>
</li></ul>

<p>11. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Mi=
scellaneous">Miscellaneous/Weirdness</a><br>
12. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Links=
">Links</a><br>
13. <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Thank=
s">Thanks</a>
</p><h2><br>
1. <a name=3D"Introduction"></a>Introduction<br>

<hr align=3D"CENTER">
</h2>
<p>This document began as a scratchpad of notes that I added onto "Agent Q'=
s GBA Spec" as I came across
new information and ideas while building the CowBite emulator. Agent Q is n=
o longer able to maintain that document.
Because there is so much additional information here, I thought it would be=
 a shame to keep it to myself, and thus
I'm releasing it again as a CowBite technical reference document. Though it=
 has the name of the CowBite emulator
on it, the information should still be more or less (and unofficially) vali=
d on actual hardware.<br>
<br>
I've tried to organize this document in a way that will be easy to navigate=
 to the section you are looking for.
I also try to update whenever I find that something is missing or erroneous=
. However, I can't catch everything
without your feedback. If you find an error, have information not listed in=
 this doc (and there is lots of <i>that</i>),
or think that something could be improved upon, please <a href=3D"mailto:So=
rcererXIII@yahoo.com">contact me</a>.
<br>
<br>
For the most part, this document is a reference and not a tutorial or instr=
uction manual. I have done my best to
provide samples and hints wherever I can, but if you are looking for a step=
-by-step guide, you will probably find
it easier to begin with a tutorial like Dovoto's <a href=3D"http://216.167.=
73.47/~dovoto/English/tutorial_5.html">Pern
Project</a>, or one of the other tutorials on <a href=3D"http://www.gbadev.=
org/">http://www.gbadev.org/</a> or in
the <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Links=
">links</a> section of this page. <br>
<br>
All of this information has been obtained legally by piecing together infor=
mation from the ARM docs, gbadev.org,
the gbadev mailing list, public domain demos, and other information such as=
 the debug info from various emulators.
My sincerest <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.=
htm#Thanks">thanks</a> to all of those
who have mailed me with info and corrections!<br>
<br>
Send me mail (<a href=3D"mailto:SorcererXIII@yahoo.com">SorcererXIII@yahoo.=
com</a>) with your comments and especially
with info and corrections. <br>
<br>
Tom Happ <br>
<br>
Revision 3.5 - (Colorful Version) Begun May 18th 2002 (Though updates are c=
ontinuous)<br>
Revision 3.0 - (HTML Version) Begun December 19th 2001<br>
Revision 2.1 - I decided to rename this 3.0, as it turned out to be a major=
 overhaul <br>
Revision 2.0 - Begun July 23, 2001 (by me)<br>
Revision 1.0 - (by Agent Q) 08/02/2001 <br>
<br>
I keep the most recent doc update at <br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm">http://w=
ww.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm</a>
</p><h2></h2>
<h3>The Basics</h3>
<p>From the programmer's perspective, the system is composed of the followi=
ng:<br>
<br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#CPU">CPU<=
/a> - A 16.78 Mhz ARM7tdmi<br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Memory%20=
Map">Memory</a> - 8 to 11 distinct areas
of memory (depending on the Game Pak).<br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Memory-Ma=
pped%20Hardware%20Registers">IO</a> - Special
hardware functions available to the programmer, primarily pertaining to gra=
phics, sound, DMA, timers, serial communication,
key input, and interrupts.<br>
<br>
Programs run on the GBA are usually contained in a "Game Pak". A "Game Pak"=
 consists mainly
of <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#GAME%2=
0PAK%20ROM">ROM</a> and possibly <a href=3D"http://www.cs.rit.edu/~tjh8300/=
CowBite/CowBiteSpec.htm#CART%20RAM">Cart
RAM</a> (in the form of SRAM, Flash ROM, or EEPROM, used mainly for save ga=
me info). The ROM is where compiled
code and data is stored. Unlike home computers, workstations, or servers, t=
here are no disks or other drives, so
everything that might otherwise have been stored as separate resource files=
 must be compiled into the program ROM
itself. Luckily there are tools to aid in this process. <br>
<br>
The primary means a program accesses specialized hardware for graphics, sou=
nd, and other IO is through the <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#Memory-Mapped%20Hardware%20Registers">memory-mapped
IO</a>. Memory mapped IO is a means of communicating with hardware by writi=
ng to/reading from specific memory addresses
that are "mapped" to internal hardware functions. For example, you might wr=
ite to address <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpe=
c.htm#REG_DISPCNT">0x4000000</a>
with the value "0x0100", which tells the hardware "enable background 0 and =
graphics mode 0".
A secondary means is through the <a href=3D"http://www.cs.rit.edu/~tjh8300/=
CowBite/CowBiteSpec.htm#System%20ROM">BIOS</a>,
which is embedded in the internal GBA system ROM. Using <a href=3D"http://w=
ww.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#BIOS%20(Software%20Interrupt=
s)">software
interrupts</a> it is possible to access pre-programmed (and hopefully optim=
ized) routines lying in the the system
ROM. These routines then access the hardware through the memory-mapped IO.<=
br>
<br>
Other regions of memory that are directly mapped to the hardware are <a hre=
f=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Palette">Palett=
e
RAM</a> (which is a table consisting of all the available colors), <a href=
=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#VRAM">VRAM</a>
(which performs a similar function to the video RAM on a PC - and thensome)=
, and <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#OAM=
">OAM</a>
(which contains the attributes for hardware accelerated sprites).
</p><h3><br>
Programming for the GBA</h3>
<p>For those wishing to learn how to write a program for the GBA, this is n=
ot really the right place. This document
is more like a reference that you can keep open in the background and quick=
ly thumb through as questions arise.
Consider the following to be a generalization of how games are developed fo=
r the GBA.<br>
<br>
C, C++, and ARM/Thumb assembly are the most common languages used in GBA de=
velopment, mainly because they are fast
and relatively low level (i.e. there is a large degree of correspondance be=
tween the structure of the language
and underlying instruction set of the architecture). Members of the <a href=
=3D"http://www.gbadev.org/">GBA development
community</a> have put together some development kits that greatly simplify=
 the task of configuring a C/C++ compiler
for GBA development. Two that I know of are Devkit Advance and HAM.<br>
<br>
Most GBA programs are structured around the timing of the CPU and graphics =
hardware. The LCD has a refresh rate
of about 59.73 hz, with each refresh consisting of a <a href=3D"http://www.=
cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#VDraw">vertical
draw</a> period (when the GBA is drawing the screen) followed by a <a href=
=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#VBlank">vertical
blank</a> period (when nothing is being drawn). The vertical draw and verti=
cal blank periods are further subdivided
into <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#HDra=
w">horizontal draw and blank</a> periods.
Programs typically use the VBlank and possibly the HBlank periods to update=
 VRAM or graphics hardware registers
in order to avoid unwanted visual artifacts, leaving the VDraw and HDraw pe=
riods to perform any software processing
that will not effect the display. Common methods of syncing to VBlank inclu=
de polling <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.ht=
m#REG_STAT">REG_DISPSTAT</a>
or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_VC=
OUNT">REG_VCOUNT</a>, calling the VBlankIntrWait
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#BIOS%20(S=
oftware%20Interrupts)">BIOS</a> function,
or setting up an <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteS=
pec.htm#Hardware%20Interrupts">interrupt</a>.<br>
<br>
I suggest the following resources as being invaluable to homebrew (and even=
 commercial) developers:<br>
<br>
<a href=3D"http://www.gbadev.org/">http://www.gbadev.org/</a> - This is one=
 of the main hubs for GBA development
on the web, containing numerous docs, tutorials, demos (many with source co=
de), tools, and news.<br>
<br>
<a href=3D"http://www.devrs.com/gba">http://www.devrs.com/gba</a> - This is=
 Jeff Frohwein's GBA site. Jeff Frohwein
is something of a GBA dev guru; you will likely hear his name mentioned oft=
en throghout the community. His site
contains many good links, documents, and tools, many of which he wrote hims=
elf.<br>
<br>
<a href=3D"http://groups.yahoo.com/group/gbadev/">http://groups.yahoo.com/g=
roup/gbadev/</a> -A forum on yahoo with
a large archive of back posts.<br>
<br>
<a href=3D"http://216.167.73.47/~dovoto/English/tutorial_1.html">PERN proje=
ct tutorials</a> - These great tutorials
by Dovoto explain everything in an easy-to-understand, step-by-step fashion=
.<br>
<br>
<a href=3D"http://www.belogic.com/gba">The Audio Advance</a> - Documents an=
d tutorials on the formerly enigmatic
GBA sound system. Courtesy of Uze.<br>
<br>
<a href=3D"http://www.io.com/~fenix/devkitadv/">Unofficial GBA Software Dev=
elopment Kit (AKA Devkit Advance</a>)
- The most popular free devkit available.<br>
<br>
<a href=3D"http://www.ngine.de/ham.html">HAM</a> - If you want to get start=
ed <i>right now</i>, Emanuel's HAM devkit
is especially easy to install, and can have you up and running in minutes.<=
/p>
<pre></pre>
<h2><br>
2. <a name=3D"CPU"></a>CPU</h2>
<p>
</p><hr align=3D"CENTER">
This section is intended to be an overview only, detailing those aspects of=
 the CPU which are important to understand
when developing for the GBA in particular. A more thorough description of t=
he ARM7tdmi CPU can be found in the
<a href=3D"http://www.arm.com/arm/TRMs?OpenDocument">technical reference ma=
nuals</a> on <a href=3D"http://www.arm.com/">ARM's
website</a>.<br>
<br>
The CPU is a 16.78 MHz ARM7tdmi RISC processor. It is a 32-bit processor bu=
t can be switched to "Thumb"
state, which allows it to handle a special subset of 16-bit instructions th=
at map to 32-bit counterparts. Instructions
follow a three-stage pipeline: fetch, decode, execute. As a result, the <a =
href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#r15%20(PC)">=
program
counter</a> always points two instructions ahead of the one currently being=
 executed.
<h3><br>
<a name=3D"CPU Registers"></a><b>CPU Registers</b></h3>
<p>16 registers are visible to the user at any given time, though there are=
 20 <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Banke=
d%20registers">banked
registers</a> which get swapped in whenever the CPU changes to various priv=
eleged modes. The registers visible
in user mode are as follows:


</p><blockquote>
	<p><b>r0-r12:</b> General purpose registers, for use in every day operatio=
ns<br>
	<a name=3D"r13 (SR)"></a><b>r13 (SR):</b> Stack pointer Register. Used pri=
marily for maintaining the address of the
	stack. This default value (initialized by the BIOS) differs depending on t=
he current <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.ht=
m#Processor%20Modes">processor
	mode</a>, as follows:</p>
	<pre>  User/System:  0x03007F00
  IRQ:          0x03007FA0
  Supervisor:   0x03007FE0</pre>
	<p>As far as I know the other modes do not have default stack pointers.<br=
>
	<br>
	<a name=3D"r14 (LR)"></a><b>r14 (LR):</b> Link Register. Used primarily to=
 store the address following a "bl"
	(branch and link) instruction (as used in function calls)<br>
	<a name=3D"r15 (PC)"></a><b>r15 (PC):</b> The Program Counter. Because the=
 ARM7tdmi uses a 3-stage pipeline, this
	register always contains an address which is 2 instructions ahead of the o=
ne currrently being executed. In 32-bit
	ARM state, it is 8 bytes ahead, while in 16-bit Thumb state it is 4 bytes =
ahead.<br>
	<a name=3D"CPSR"></a><b>CPSR:</b> The Current Program Status Register. Thi=
s contains the status bits relevant to
	the CPU -</p>
	<pre>31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  11 1=
0 9 8  7 6 5 4  3 2 1 0
<font color=3D"#008800">N </font> <font color=3D"#0099FF">Z </font> <font c=
olor=3D"#9900CC">C</font> <font color=3D"#FF0099"> V </font> <font color=3D=
"#FF3300"> R  R  R  R   R  R  R  R   R  R  R  R   R  R  R  R   R  R  R R </=
font><font color=3D"#008800"> I </font><font color=3D"#0099FF">F</font> <fo=
nt color=3D"#9900CC">T</font> <font color=3D"#FF0099">M  M M M M</font></pr=
e>
	<pre>0-4 <font color=3D"#FF0099"> (M)</font> =3D Mode bits. These indicate=
 the current processor mode:
           10000 - <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBit=
eSpec.htm#User">User mode
</a>           10001 - <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Co=
wBiteSpec.htm#FIQ">FIQ mode</a>
           10010 - <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBit=
eSpec.htm#IRQ">IRQ mode
</a>           10011 - <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Co=
wBiteSpec.htm#SVC">Supervisor mode
</a>           10111 - <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Co=
wBiteSpec.htm#ABT">Abort mode
</a>           11011 - <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Co=
wBiteSpec.htm#UND">Undefined mode
</a>           11111 - <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Co=
wBiteSpec.htm#System">System mode</a></pre>
	<pre>5    <font color=3D"#9900CC">(T)</font> =3D <a href=3D"http://www.cs.=
rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Thumb%20State">Thumb state</a> ind=
icator. If set, the CPU is in Thumb state.=20
           Otherwise it operates in normal ARM state. Software should
           never attempt to modify this bit itself.
6    <font color=3D"#0099FF">(F)</font> =3D FIQ interrupt disable. Set this=
 to disable FIQ interrupts.
7 <font color=3D"#008800">   (I)</font> =3D <a href=3D"http://www.cs.rit.ed=
u/~tjh8300/CowBite/CowBiteSpec.htm#Hardware%20Interrupts">IRQ interrupt</a>=
 disable. Set this to disable IRQ interrupts. On
           the GBA this is set by default whenever IRQ mode is entered.
           Why or how this is the case, I do not know.
8-27<font color=3D"#FF3300"> (R)</font> =3D Reserved
28 <font color=3D"#FF0099">  (V)</font> =3D Overflow condition code
29 <font color=3D"#9900CC">  (C)</font> =3D Carry/Borrow/Extend condition c=
ode
30 <font color=3D"#0099FF">  (Z)</font> =3D Zero/Equal condition code
31 <font color=3D"#008800">  (N)</font> =3D Negative/Less than condition co=
de</pre>

</blockquote>

<h3><a name=3D"Processor Modes"></a><b>Processor Modes</b></h3>
<p>The ARM7tdmi has six modes: user, system, IRQ, FIQ, SVC, Undef, and Abt.=
 The default is user mode. Certain events
will trigger a mode switch. Some modes cause an alternate set of registers =
to be swapped in, effectively replacing
the current set of registers until the mode is exited.<br>
<br>
<a name=3D"User"></a><b>User: </b>This is the default mode.<br>
<br>
<a name=3D"System"></a><b>System:</b> This is intended to be a priveleged u=
ser mode for the operating system. As
far as I can tell it is otherwise the same as User mode. I am not sure if t=
he GBA ever enters System mode during
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#BIOS%20(S=
oftware%20Interrupts)">BIOS</a> calls.<br>
<br>
<a name=3D"IRQ"></a><b>IRQ:</b> This mode is entered when an Interrupt Requ=
est is triggered. Any interrupt handler
on the GBA will be called in IRQ mode.


</p><blockquote>
	<p><a name=3D"Banked registers"></a>Banked registers: The ARM7tdmi has sev=
eral sets of banked registers that get
	swapped in place of normal user mode registers when a priveleged mode is e=
ntered, to be swapped back out again
	once the mode is exited. In IRQ mode, r13_irq and r14_irq will be swapped =
in to replace r13 and r14. The current
	<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#CPSR">CP=
SR</a> contents gets saved in the SPSR_irq
	register.</p>

</blockquote>

<p><a name=3D"FIQ"></a><b>FIQ:</b> This mode is entered when a Fast Interru=
pt Request is triggered. Since all of
the hardware interrupts on the GBA generate IRQs, this mode goes unused by =
default, though it would be possible
to switch to this mode manually using the "msr" instruction.


</p><blockquote>
	<p>Banked registers: r8_fiq, r9_fiq, r10_fiq, r11_fiq, r12_fiq, r13_fiq, r=
14_fiq, and SPSR_fiq.</p>

</blockquote>

<p><a name=3D"SVC"></a><b>SVC:</b> Supervisor mode. Entered when a SWI (sof=
tware interrupt) call is executed. The
GBA enters this state when calling the <a href=3D"http://www.cs.rit.edu/~tj=
h8300/CowBite/CowBiteSpec.htm#BIOS%20(Software%20Interrupts)">BIOS</a>
via SWI instructions.


</p><blockquote>
	<p>Banked registers: r13_svc, r14_svc, SPSR_svc.</p>

</blockquote>

<p><a name=3D"ABT"></a><b>ABT:</b> Abort mode. Entered after data or instru=
ction prefetch abort.


</p><blockquote>
	<p>Banked registers: r13_abt, r14_abt, SPSR_abt.</p>

</blockquote>

<p><a name=3D"UND"></a><b>UND:</b> Undefined mode. Entered when an undefine=
d instruction is executed.


</p><blockquote>
	<p>Banked registers: r13_und, r14_und, SPSR_und.</p>

</blockquote>

<p>
</p><h3><a name=3D"CPU State"></a>CPU State</h3>
<p>The ARM7tdmi has two possible states, either of which may be entered wit=
hout fear of losing register contents
or current processor mode.<br>
<br>
<a name=3D"Thumb State"></a><b>To enter Thumb State</b>: In this state the =
CPU executes 16-bit, halfword-aligned
instructions. There are two ways it can be entered:

</p><ul>
	<li>A BX rn, where rn contains the address of the thumb instructions to be=
 executed, +1. Bit 0 must be 1 or the
	switch won't be made and the CPU will try to interperet the binary Thumb c=
ode as 32-bit ARM instructions.
	</li><li>Returning from an <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBi=
te/CowBiteSpec.htm#Hardware%20Interrupts">interrupt</a>
	that was entered while in Thumb mode.
	</li><li>Executing any arithmetic instruction with the PC as the target an=
d the 'S' bit of the instruction set, with
	bit 0 of the new PC being 1.
</li></ul>

<p><a name=3D"ARM State"></a><b>To Enter ARM State:</b> This is the default=
 state. It executes 32-bit, word-aligned
instructions. When in Thumb state, the CPU can be switched back to ARM stat=
e by:

</p><ul>
	<li>A BX rn, where rn contains the address of the ARM instructions to be e=
xecuted. Bit 0 must be 0.
	</li><li>Entering an <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Cow=
BiteSpec.htm#Hardware%20Interrupts">interrupt</a>.
</li></ul>

<p><b><br>
For more complete information on the ARM7tdmi, be sure to check out ARM's <=
/b><a href=3D"http://www.arm.com/arm/TRMs?OpenDocument"><b>technical
reference manuals</b></a><b>.</b>
</p><h2><br>
3. <a name=3D"Memory Map"></a>Memory<br>

<hr align=3D"CENTER">
</h2>
<p>The following are the general areas of memory as seen by the CPU, and wh=
at they are used for. <br>
<br>
<a name=3D"System ROM"></a><b>System ROM:</b></p>
<pre>Start: 0x00000000
End:  0x0003FFF
Size: 16kb=20
Port Size: 32 bit
Wait State: 0</pre>
<p>0x0 - 0x00003FFF contain the <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#BIOS%20(Software%20Interrupts)">BIOS</a>,
which is executable but not readable. Any attempt to read in the area from =
0x0 to 0x1FFFFFFF will result in failure;
what you will see on a read is the current prefetched instruction (the inst=
ruction after the instruction used to
view the memory area), thus giving the appearance that this area of memory =
consists of a repeating byte pattern.
<br>
<b><br>
<a name=3D"External Work RAM"></a>External Work RAM:</b></p>
<pre>Start: 0x02000000
End:   0x0203FFFF
Size:  256kb
Port Size: 16 bit
Mirrors:  Every 0x40000 bytes from 0x02000000 to 0x02FFFFFF
</pre>
<p>This space is available for your game's data and code. If a multiboot ca=
ble is present on startup, the BIOS
automatically detects it and downloads binary code from the cable and place=
s it in this area, and execution begins
with the instruction at address 0x02000000 (the default is 0x08000000). Tho=
ugh this is the largest area of RAM
available on the GBA, memory transfers to and from EWRAM are 16 bits wide a=
nd thus consume more cycles than necessary
for 32 bit accesses. Thus it is advised that 32 bit ARM code be placed in <=
a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Internal%2=
0Work%20RAM">IWRAM</a>
rather than EWRAM.<br>
<b><br>
<a name=3D"Internal Work RAM"></a>Internal Work RAM:</b></p>
<pre>Start: 0x03000000
End:   0x03007FFF
Size:  32kb
Port Size: 32 bit
Mirrors:  Every 0x8000 bytes from 0x03000000 to 0x03FFFFFF</pre>
<p>This space is also available for use. It is the fastest of all the GBA's=
 RAM, being internally embedded in the
ARM7 CPU chip package and having a 32 bit bus. As the bus for <a href=3D"ht=
tp://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#GAME%20PAK%20ROM">ROM<=
/a>
and <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Exter=
nal%20Work%20RAM">EWRAM</a> is only 16 bits
wide, the greatest efficiency will be gained by placing 32 bit ARM code in =
IWRAM while leaving thumb code for <a href=3D"http://www.cs.rit.edu/~tjh830=
0/CowBite/CowBiteSpec.htm#External%20Work%20RAM">EWRAM</a> or <a href=3D"ht=
tp://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#GAME%20PAK%20ROM">ROM<=
/a>
memory.<br>
<br>
<a name=3D"IO Ram"></a><b>IO Ram:</b></p>
<pre>Start: 0x04000000
End:   0x040003FF (0x04010000)
Size:  1Kb
Port Size:  Dual ported 32 bit
Mirrors:  The word at 0x04000800 (only!) is mirrored every 0x10000 bytes
          from 0x04000000 - 0x04FFFFFF.
</pre>
<p>This area contains a mirror of the ASIC (Application Specific Integrated=
 Circuit) registers on the GBA. This
area of memory is used to control the graphics, sound, DMA, and other featu=
res. See <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#=
Memory-Mapped%20Hardware%20Registers">memory-mapped
IO registers</a> for details on the function of each register.<br>
<br>
<a name=3D"Palette"></a><b>Palette RAM:</b></p>
<pre>Start: 0x05000000
End:   0x050003FF
Size:  1kb
Port Size:  16 bit
Mirrors: Every 0x400 bytes from 0x05000000 to 0x5FFFFFF</pre>
<p>This area specifies the <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBit=
e/CowBiteSpec.htm#Color%20Format">16-bit
color</a> values for the paletted modes. There are two areas of the palette=
: one for backgrounds (0x05000000) and
another for sprites (0x05000200). Each of these is either indexed as a sing=
le, 256-color palette, or as 16 individual
16-color palettes, depending on the settings of a particular <a href=3D"htt=
p://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Attribute%200">sprite</=
a>
or background. <br>
<b><br>
<a name=3D"VRAM"></a>VRAM:</b></p>
<pre>Start: 0x06000000
End:   0x06017FFF
Size:  96kb
Port Size: 16 bit
Mirrors: Bytes 0x06010000 - 0x06017FFF is mirrored from 0x06018000 - 0x0601=
FFFF.
         The entire region from 0x06000000 - 0x06020000 is in turn mirrored=
 every
         0x20000 bytes from 0x06000000 - 0x06FFFFFF.</pre>
<p>The video RAM is used to store the frame buffer in <a href=3D"http://www=
.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Bitmapped%20Backgrounds">bitma=
pped</a>
modes, and the tile data and tile maps for tile-based <a href=3D"http://www=
.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Text%20Backgrounds">"text"</a>
and <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Scale=
/Rotate%20Backgrounds">rotate/scale</a>
modes. <br>
<b><br>
<a name=3D"OAM"></a>OAM:</b></p>
<pre>Start: 0x07000000
End:   0x070003FF
Size:  1kb
Port Size: 32 bit
Mirrors: Every 0x400 bytes from 0x07000000 to 0x07FFFFFF</pre>
<p>This is the Object Attribute Memory, and is used to control the GBA's <a=
 href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#OAM%20(spri=
tes)">sprites</a>.
<b><br>
<br>
<br>
The following areas of memory are technically cart-dependent, but can gener=
ally be expected to behave as described.<br>
<br>
<a name=3D"GAME PAK ROM"></a>GAME PAK ROM:</b></p>
<pre>Start: 0x08000000
Size:  The size of the cartridge (0 - 32 megabytes)=20
Port Size: 16 bit
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_WS_CR=
">Wait State</a>: 0</pre>
<p>The ROM in the game cartridge appears in this area. If a cartridge is pr=
esent on startup, the instruction found
at location 0x08000000 is loaded into the program counter and execution beg=
ins from there. Note that the transfers
to and from ROM are all 16 bits wide.<br>
<b><br>
GAME PAK <a name=3D"ROM IMAGE 1"></a>ROM IMAGE 1:</b></p>
<pre>Start: 0x0A000000
Size:  The size of the cartridge (0 - 32 megabytes)
Port Size:  16 bit
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_WS_CR=
">Wait State</a>: 1</pre>
<p>This is a mirror of the ROM above. Used to allow multiple speed ROMs in =
a single game pak. <br>
<b><br>
GAME PAK <a name=3D"ROM IMAGE 2"></a>ROM IMAGE 2:</b></p>
<pre>Start: 0x0C000000
Size:  The size of the cartridge (0 - 32 megabytes)
Port Size: 16 bit
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_WS_CR=
">Wait State</a>: 2</pre>
<p>This is a mirror of the ROM above. Used to allow multiple speed ROMs in =
a single game pak. <br>
<b><br>
<a name=3D"CART RAM"></a>CART RAM:</b></p>
<pre>Start: 0x0E000000 (also seem to appear at 0x0F000000)
Size:  0 - 64 kb
Port Size: 8 bit
</pre>
<p>This is either SRAM or Flash ROM. Used primarily for saving game data. S=
RAM can be up to 64kb but is usually
32 kb. It has a battery backup so has the longest life (in terms of how man=
y times it can be written to) of all
backup methods. Flash ROM is usually 64 kb. Its lifespan is determined by t=
he number of rewrites that can be done
per sector (a 10,000 rewrite minimum is cited by some manufacturers).<br>
<br>
<a name=3D"EEPROM"></a><b>EEPROM:</b><br>
This is another kind of cart memory, but operates differently from SRAM or =
Flash ROM. Unfortunately, I don't know
the details of how it can be accessed by the programmer (<a href=3D"http://=
www.cs.rit.edu/~tjh8300/CowBite/SorcererXIII@yahoo.com">mail
me</a> if you have more information on it). It uses a serial connection to =
transmit data. The maximum size is 128
mb, but it can be any size, and is usually 4 kb or 64 kb. Like Flash ROM it=
 has a limited life; some manufacturers
cite a minimum of 100,000 rewrites per sector.<br>
<br>
There may be other regions of memory known as DEBUG ROM 1 and DEBUG ROM 2, =
though I really don't know whether these
are a part of commercial carts or if they are mapped to some part of the in=
ternal ROM, or if they're even available
on a standard GBA. <br>
<br>
Note that EWRAM, IWRAM, VRAM, OAM, Palette RAM are all initialized to zero =
by the BIOS (i.e. you can expect them
to be zeroed at startup).
</p><h2><br>
4. <a name=3D"Graphics Hardware Overview"></a>Graphics Hardware Overview<br=
>

<hr align=3D"CENTER">
</h2>
<p>The GBA has a TFT color LCD that is 240 x 160 pixels in size and has a r=
efresh rate of exactly 280,896 cpu cycles
per frame, or around 59.73 hz. Most GBA programs will need to structure the=
mselves around this refresh rate. Each
refresh consists of a 160 scanline vertical draw (<a name=3D"VDraw"></a>VDr=
aw) period followed by a 68 scanline blank
(<a name=3D"VBlank"></a>VBlank) period. Furthermore, each of these scanline=
s consists of a 1004 cycle draw period
(<a name=3D"HDraw"></a>HDraw) followed by a 228 cycle blank period (<a name=
=3D"HBlank"></a>HBlank). During the HDraw
and VDraw periods the graphics hardware processes background and obj (sprit=
e) data and draws it on the screen,
while the HBlank and VBlank periods are left open so that program code can =
modify background and obj data without
risk of creating graphical artifacts.
</p><h3><a name=3D"Video Modes"></a>Video Modes</h3>
<p>Exactly what the GBA draws on screen depends largely on the current vide=
o mode (also sometimes referred to as
the <i>screen mode</i> or <i>graphics mode</i>). The GBA has 6 such modes, =
some of which are <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBite=
Spec.htm#Bitmapped%20Backgrounds">bitmap</a>-based
and some of which are <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Cow=
BiteSpec.htm#Text%20Backgrounds">tile-based</a>.
The video mode is set by the bottom three bits of the hardware register kno=
wn as <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG=
_DISPCNT">REG_DISPCNT</a>.
Background data is handled differently depending on what mode is enabled. B=
ackgrounds can either be <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/=
CowBiteSpec.htm#Text%20Backgrounds">text
backgrounds</a> (tile based), <a href=3D"http://www.cs.rit.edu/~tjh8300/Cow=
Bite/CowBiteSpec.htm#Scale/Rotate%20Backgrounds">rotate-scale
backgrounds</a> (tile based backgrounds that can be transformed), or <a hre=
f=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Bitmapped%20Bac=
kgrounds">bitmap
backgrounds</a>. The starting address and size sprite graphics memory is al=
so dependent on video mode.  It starts
at 0x6010000 for tile modes and 0x6014000 for <a href=3D"http://www.cs.rit.=
edu/~tjh8300/CowBite/CowBiteSpec.htm#Bitmapped%20Backgrounds">bitmapped</a>
modes.<br>
<br>
Enabling objs and one or more backgrounds in <a href=3D"http://www.cs.rit.e=
du/~tjh8300/CowBite/CowBiteSpec.htm#REG_DISPCNT">REG_DISPCNT</a>
will cause the GBA to draw the specified backgrounds and objs in order of p=
riority. <br>
<br>
<a name=3D"Mode 0"></a><b>Mode 0:<br>
</b>In this mode, four text background layers can be shown. In this mode ba=
ckgrounds 0 - 3 all count as <a href=3D"http://www.cs.rit.edu/~tjh8300/CowB=
ite/CowBiteSpec.htm#Text%20Backgrounds">"text"</a>
backgrounds, and cannot be scaled or rotated. Check out the section on <a h=
ref=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Text%20Backgr=
ounds">text
backgrounds</a> for details on this. <br>
<br>
<a name=3D"Mode 1"></a><b>Mode 1:</b><br>
This mode is similar in most respects to Mode 0, the main difference being =
that only 3 backgrounds are accessible
-- 0, 1, and 2. Bgs 0 and 1 are <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#Text%20Backgrounds">text
backgrounds</a>, while bg 2 is a <a href=3D"http://www.cs.rit.edu/~tjh8300/=
CowBite/CowBiteSpec.htm#Scale/Rotate%20Backgrounds">rotation/scaling</a>
background.<br>
<br>
<a name=3D"Mode 2"></a><b>Mode 2:</b><br>
Like modes 0 and 1, this uses tiled backgrounds. It uses backgrounds 2 and =
3, both of which are <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowB=
iteSpec.htm#Scale/Rotate%20Backgrounds">rotate/scale
backgrounds</a>. <br>
<br>
<a name=3D"Mode 3"></a><b>Mode 3:</b> <br>
Standard 16-bit bitmapped (non-paletted) 240x160 mode. The map starts at 0x=
06000000 and is 0x12C00 bytes long.
See the <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#C=
olor%20Format">Color Format</a> table above
for the format of these bytes. <br>
<br>
This allows the full color range to be displayed at once. Unfortunately, th=
e frame buffer in this mode is too large
for page flipping to be possible. One option to get around this would be to=
 copy a frame buffer from work RAM into
VRAM during the retrace, or (so I have heard) to use <a href=3D"http://www.=
cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_DMA3CNT">DMA3</a>
with the start mode bits set to 11.<br>
<br>
<a name=3D"Mode 4"></a><b>Mode 4:</b><br>
8-Bit paletted bitmapped mode at 240x160. The bitmap starts at either 0x060=
00000 or 0x0600A000, depending on bit
4 of <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_=
DISPCNT">REG_DISPCNT</a>. Swapping the
map and drawing in the one that isn't displayed allows for page flipping te=
chniques to be used. The palette is
at 0x5000000, and contains 256 16-bit <a href=3D"http://www.cs.rit.edu/~tjh=
8300/CowBite/CowBiteSpec.htm#Color%20Format">color
entries</a>. <br>
<br>
<a name=3D"Mode 5"></a><b>Mode 5:</b><br>
This is another 16-bit bitmapped mode, but at a smaller resolution of 160x1=
28. The display starts at the upper
left hand corner of the screen, but can be shifted using the rotation and s=
caling registers for BG2. The advantage
of using this mode is presumably that there are two frame buffers available=
, and this can be used to perform page
flipping effects which cannot be done in mode 3 due to the smaller memory r=
equirements of mode 5. Bit 4 of <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#REG_DISPCNT">REG_DISPCNT</a>
sets the start of the frame buffer to 0x06000000 when bit 4 is zero, and 0x=
600A000 when bit 4 is one.
</p><h3><a name=3D"Color Format"></a><b>Color Format:</b></h3>
<p>All colors (both paletted and bitmapped) are represented as a 16 bit val=
ue, using 5 bits for red, green, and
blue, and ignoring bit 15. In the case of paletted memory, pixels in an ima=
ge are represented as 8 bit or 4 bit
indices into the <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteS=
pec.htm#Palette">palette RAM</a> starting
at 0x5000000 for backgrounds and 0x5000200 for sprites. Each palette is a t=
able consisiting of 256 16-bit color
entries. In the case of the bitmapped backgrounds in modes 3 and 4, pixels =
are represented as the 16-bit color
values themselves.</p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X</font> <font color=3D"#0000DD">B B B  B B</font> =
<font color=3D"#008800">G G  G G G</font> <font color=3D"#DD0000">R  R R R =
R</font></pre>
<pre>0-4 <font color=3D"#DD0000">(R)</font> =3D Red
5-9 <font color=3D"#008800">(G)</font> =3D Green
A-F <font color=3D"#0000DD">(B)</font> =3D Blue</pre>
<p>
</p><h2>5. <a name=3D"Backgrounds"></a>Backgrounds</h2>
<p>Depending on the current <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBi=
te/CowBiteSpec.htm#Video%20Modes">video
mode</a>, three different types of backgrounds are available. They are
</p><h3><a name=3D"Text Backgrounds"></a>Text Backgrounds:</h3>
<p>These are tile-based backgrounds that descend from the usage of tiles to=
 display characters in text modes of
a PC or workstation. They are made up of 8x8 tiles, the bitmaps of which ar=
e stored at the tile data address. The
address of this data is set using registers <a href=3D"http://www.cs.rit.ed=
u/~tjh8300/CowBite/CowBiteSpec.htm#REG_BG0">REG_BG0CNT
- REG_BG3CNT</a>. The <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Cow=
BiteSpec.htm#REG_BG0SCX">HOFS</a> and
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_BG0SC=
Y">VOFS</a> registers can be used to scroll
around a larger area of up to 512x512 pixels (or 64 x 64 tiles). <br>
<br>
In text backgrounds, the data for each pixel is stored as an 8 or 4 bit pal=
ette index. In 8-bit mode, the <a href=3D"http://www.cs.rit.edu/~tjh8300/Co=
wBite/CowBiteSpec.htm#Palette">palette</a>
is at 0x05000000 stores a 15-bit color value for each of the 256 palette en=
tries. In 4-bit mode, the the map index
contains a 4-bit value indicating which of 16 16-color palettes to use for =
each tile. Each of these palettes is
32 bytes long and can be found at 0x05000000, 0x05000020, etc.
</p><h3><a name=3D"Scale/Rotate Backgrounds"></a><b>Scale/Rotate Background=
s</b>:</h3>
<p>These backgrounds are also tile-based, and operate similarly to Text Bac=
kgrounds. However, these backgrounds
may also be <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.h=
tm#Background%20Rotation/Scaling%20Regi">scaled
or rotated</a>. Additionally they may only use an 8-bit <a href=3D"http://w=
ww.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Palette">palette</a>,
and can vary in size from 128 to 1024 pixels across. The palette is at 0x50=
00000, and contains 256 16-bit <a href=3D"http://www.cs.rit.edu/~tjh8300/Co=
wBite/CowBiteSpec.htm#Color%20Format">color
entries</a>
</p><h3><a name=3D"Bitmapped Backgrounds"></a><b>Bitmapped Backgrounds</b>:=
</h3>
<p>These backgrounds vary depending on the <a href=3D"http://www.cs.rit.edu=
/~tjh8300/CowBite/CowBiteSpec.htm#Video%20Modes">video
mode</a>, but in all cases they rely on a single buffer upon which the imag=
e is drawn, either using an 8-bit palette
or 16-bit color entries themsevles. Bitmap backgrounds are treated as BG2 f=
or purposes of rotation, scaling, and
blending. In the bitmap modes the frame buffer data extends into the obj ti=
le data region, limiting it to the range
from 0x6014000 - 0x6018000 (sprite indices 512 - 1024).
</p><h3><a name=3D"Background Map Entry Format"></a><b>Background Map Entry=
 Format</b></h3>
<p><a name=3D"Text Background Map Format:"></a><a href=3D"http://www.cs.rit=
.edu/~tjh8300/CowBite/CowBiteSpec.htm#Text%20Backgrounds"><b>Text
Background</b></a><b> Map Format</b>: <br>
The tile map, which stores the layout of the tiles on screen, begins at the=
 tile map address found for a particular
background, detrmined by <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/=
CowBiteSpec.htm#REG_BG0">REG_BG0CNT -
REG_BG3CNT</a>. It has a selectable size up to 512x512. The tile map contai=
ns a 16-bit entry for each tile, with
has the following format:</p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#008800">L L L L</font>  <font color=3D"#0099FF">V</font> <f=
ont color=3D"#9900CC">H</font> <font color=3D"#FF0099">T T  T T T T  T T T =
T</font> </pre>
<pre>0-9 <font color=3D"#FF0099">(T)</font> =3D The tile number=20
A <font color=3D"#9900CC">  (H)</font> =3D If this bit is set, the tile is =
flipped horizontally left to right.=20
B <font color=3D"#0099FF">  (V)</font> =3D If this bit is set, the tile is =
flipped vertically upside down.=20
C-F <font color=3D"#008800">(L)</font> =3D Palette number </pre>
<p><br>
For 256 x 256 and 256 x 512 backgrounds, the formula for calculating a map =
index is roughly,


</p><blockquote>
	<p>mapEntry =3D tileMapAddress[(tileY * 32) + tileX]</p>

</blockquote>

<p>For text mode sizes 512 x 256 and 512 x 512 backgrounds, however, the ma=
p is 64 tiles across, and these are
stored in blocks of 32 * 32 tiles. This means that to calculate the map ent=
ry that would appear 33 tiles or more
across the background, the following equation should be used:


</p><blockquote>
	<p>mapEntry =3D tileMap[(tileY * 32) + (tileX - 32) + 32*32]</p>

</blockquote>

<p>For entries 33 tiles or more down (in mode 11), use


</p><blockquote>
	<p>mapEntry =3D tileMap[( (tileY-32) * 32) + tileX + 2*32*32];</p>

</blockquote>

<p>And for entries 33 tiles or more down and 33 tiles or more across,


</p><blockquote>
	<p>mapEntry =3D tileMap[( (tileY-32) * 32) + (tileX-32) + 3*32*32];</p>

</blockquote>

<p><br>
<a name=3D"Rotational Background Map Format"></a><b>Rotational Background M=
ap Format : </b><br>
This is the same idea as the <a href=3D"http://www.cs.rit.edu/~tjh8300/CowB=
ite/CowBiteSpec.htm#Text%20Background%20Map%20Format:">text
background</a> map format, but you only have 8 bits for each entry. The for=
mat for the tile map entries is</p>
<pre>7 6 5 4 3 2 1 0=20
<font color=3D"#FF0099">T T T T T T T T</font> </pre>
<pre>0-7 <font color=3D"#FF0099">(T)</font> =3D The tile number </pre>
<p><br>
Rotational backgrounds do not divide tile maps into blocks.<br>
<br>

</p><hr align=3D"CENTER">
<br>
For specific details on the format of background data and map entries, chec=
k out the section on <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowB=
iteSpec.htm#REG_BG0">REG_BG0CNT
- REG_BG3CNT</a> (addresses 0x04000008 - 0x0400000E). <br>
<br>
In all modes up to 128 sprites can be displayed as well as the 4 background=
 layers. These use the second <a href=3D"http://www.cs.rit.edu/~tjh8300/Cow=
Bite/CowBiteSpec.htm#Palette">palette</a>
which is located at 0x05000200. See the <a href=3D"http://www.cs.rit.edu/~t=
jh8300/CowBite/CowBiteSpec.htm#OAM%20(sprites)">OAM</a>
section for details on how to display sprites. <br>
<br>
Both background tiles and sprites use palette entry 0 as the transparent co=
lor. Pixels in this color will not be
drawn, and allow other background layers and sprites to show through.
<h2><br>
6. <a name=3D"OAM (sprites)"></a>OAM (sprites)</h2>
<p><br>
The GBA supports 128 simultaneous sprites. These can be up to 64x64 pixels =
in size. The OAM, which starts at 0x07000000,
has one entry for each of the 128 sprites. Intermixed with this data are th=
e rotation/scaling attributes, of which
there are 32 sets of 4 16 bit values. <br>
<br>
Each OAM entry is 8 bytes long and has the following format: <br>
<br>
<b>Bytes 1 and 2 (<a name=3D"Attribute 0"></a>Attribute 0)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#9900CC">S S</font> <font color=3D"#FF0099">A</font> <font c=
olor=3D"#FF3300">M</font>  <font color=3D"#008800">T T</font> <font color=
=3D"#0099FF">D</font> <font color=3D"#9900CC">R</font> <font color=3D"#FF00=
99"> J J J J  J J J J</font>
</pre>
<pre>0-7 <font color=3D"#FF0099">(J)</font> =3D Y co-ordinate of the sprite=
 (pixels). Note that for regular sprites,
          this is the y coordinate of the upper left corner. For rotate/sca=
le
          sprites, this is the y coordinate of the sprite's center. center =
.
          Note on Coordinates: The values actually wrap around: to achieve =
a -1
          y coordinate, use y =3D 255.

8   <font color=3D"#9900CC">(R)</font> =3D Rotation/Scaling on/off=20
9 <font color=3D"#0099FF">  (D)</font> =3D 0 - sprite is single sized;
          1 - sprite is virtually double sized; allowing sheared sprite pix=
els to
              overflow sprite the size (specified by bits 14 - 15 of
              <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec=
.htm#Attribute%201">OAM attribute 1</a>). A 16x16 sized sprite is treated i=
nternaly as a
              32x32 sprite. This specification comes in evidence when rotat=
ing a
              sprite at 45=B0, since the H/V size of the sprite becomes=20
              SQRT(16=B2 + 16=B2) =3D SQRT(512) =3D~ 22.62 pixels. This wil=
l cause the
              sprite to appear clipped if this bit is set to 0.=20
              (Thanks to Kay for the description)


A-B <font color=3D"#008800">(T)</font> =3D 00 - normal
          01 - semi-transparent
          10 - obj window
          11 - illegal code
         =20
          Note that semi-transparent sprites appear as transparent even if
          <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#REG_BLDCNT">REG_BLDMOD</a> has the sprites bit turned off.  Also note that
          sprites cannot be blended against one another.  For more details,=
 see
          <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#REG_BLDCNT">REG_BLDMOD.</a>

C <font color=3D"#FF3300">  (M)</font> =3D enables mosaic for this sprite.
D <font color=3D"#FF0099">  (A)</font> =3D 256 color if on, 16 color if off=
=20
E-F <font color=3D"#9900CC">(S)</font> =3D See below </pre>
<p><br>
<b>Bytes 3 and 4 (<a name=3D"Attribute 1"></a>Attribute 1)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#008800">S S</font><font color=3D"#0099FF"> V</font> <font c=
olor=3D"#9900CC">H</font>  <font color=3D"#BBBBBB">X X X</font> <font color=
=3D"#FF0099">I  I I I I  I I I I</font>	(standard sprites)
<font color=3D"#008800">S S</font> <font color=3D"#FF3300">F F  F F F</font=
> <font color=3D"#FF0099">I  I I I I  I I I I </font> (rotation/scaling on)=
</pre>
<pre>0-8 <font color=3D"#FF0099">(I)</font> =3D X coordinate of the sprite =
(pixels). For regular sprites,
          this is the x coordinate of the upper left corner. For rotate/sca=
le
          sprites, this is the x coordinate of the sprite's center.=20
          Note on coordinates: The values actually wrap around. To achieve =
a=20
          -1 x, use x =3D 511.

C <font color=3D"#9900CC">  (H)</font> =3D The flip horizinal bit
D <font color=3D"#0099FF">  (V)</font> =3D The flip vertical bit

9-D <font color=3D"#FF3300">(F)</font> =3D For rotation scaling sprites, th=
e index into the rotation data to
          be used for that sprite. This index can be from 0 - 31. The
          rotation/scaling data is located in OAM <a href=3D"http://www.cs.=
rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Attribute%203">attribute 3</a> (by=
tes 7 and 8).
          However, instead of the rotation and scaling data going with the
          corresponding sprite, it is separated accross four sequential spr=
ites.
          This index can be thought of as referencing into an array of
          four-sprite blocks, 32 bytes each.=20

E-F <font color=3D"#008800">(S)</font> =3D Size of the sprite. The top two =
bits of the size value are found in
          <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Attribute%200">attribute 0</a> and the bottom two bits=20
are in attribute 1. This forms a=20
          4-bit value which sets the size of the sprite in the following wa=
y:

          <font color=3D"#9900CC">00</font><font color=3D"#008800">00</font=
>: 8  x 8         <font color=3D"#9900CC">10</font><font color=3D"#008800">=
00</font>: 8  x 16
          <font color=3D"#9900CC">00</font><font color=3D"#008800">01</font=
>: 16 x 16        <font color=3D"#9900CC">10</font><font color=3D"#008800">=
01</font>: 8  x 32
          <font color=3D"#9900CC">00</font><font color=3D"#008800">10</font=
>: 32 x 32        <font color=3D"#9900CC">10</font><font color=3D"#008800">=
10</font>: 16 x 32
          <font color=3D"#9900CC">00</font><font color=3D"#008800">11</font=
>: 64 x 64        <font color=3D"#9900CC">10</font><font color=3D"#008800">=
11</font>: 32 x 64
          <font color=3D"#9900CC">01</font><font color=3D"#008800">00</font=
>: 16 x 8         <font color=3D"#9900CC">11</font><font color=3D"#008800">=
00</font>: Not used
          <font color=3D"#9900CC">01</font><font color=3D"#008800">01</font=
>: 32 x 8         <font color=3D"#9900CC">11</font><font color=3D"#008800">=
01</font>: Not used
          <font color=3D"#9900CC">01</font><font color=3D"#008800">10</font=
>: 32 x 16        <font color=3D"#9900CC">11</font><font color=3D"#008800">=
10</font>: Not used
         <font color=3D"#9900CC"> 01</font><font color=3D"#008800">11</font=
>: 64 x 32        <font color=3D"#9900CC">11</font><font color=3D"#008800">=
11</font>: Not used</pre>
<pre></pre>
<p><br>
<b>Bytes 5 and 6 (<a name=3D"Attribute 2"></a>Attribute 2)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#0099FF">L L L L</font>  <font color=3D"#9900CC">P P</font> =
<font color=3D"#FF0099">T T  T T T T  T T T T</font></pre>
<pre>0-9 <font color=3D"#FF0099">(T)</font> =3D Tile number. This value ind=
exes selects the bitmap of the tile to be
          displayed by indexing into the tile data area. Each index refernc=
es
          32 bytes, so the memory address of a tile is roughly 0x6010000 + =
T*32.
          (see <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpe=
c.htm#Sprite%20Tile%20Data">Sprite Tile Data</a> for details)=20

A-B <font color=3D"#9900CC">(P)</font> =3D <a href=3D"http://www.cs.rit.edu=
/~tjh8300/CowBite/CowBiteSpec.htm#Priority">Priority</a>. This controls the=
 priority of the sprite. Note thate sprites take
          precedence over backgrounds of the same priority.  See the <a hre=
f=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Priority">descr=
iption of
</a>          <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec=
.htm#Priority">priority</a> under REG_BG0 - REG_BG3 for a more detailed exp=
lanation.

C-F <font color=3D"#0099FF">(L)</font> =3D Palette number. If you use 16 co=
lor <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Palet=
te">palettes</a>, this tells you which pallette
          number to use. </pre>
<p><br>
<b>Bytes 7 and 8 (<a name=3D"Attribute 3"></a>Attribute 3)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#0099FF">S</font> <font color=3D"#9900CC">I I I  I I I I</fo=
nt>  <font color=3D"#FF0099">F F F F  F F F F</font></pre>
<pre>0-7 <font color=3D"#FF0099">(F)</font> =3D Fraction.=20
8-E <font color=3D"#9900CC">(I)</font> =3D Integer
F =3D <font color=3D"#0099FF">(S)</font> =3D Sign bit</pre>
<p><br>
These bytes control sprite rotation and scaling. Instead of the rotation an=
d scaling data going with the corresponding
sprite, it is separated accross four sequential sprites. This is indexed by=
 bits 9 - 13 in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSp=
ec.htm#Attribute%201">attribute
1</a> (bytes 3 and 4). Note that these are all relative to the center of th=
e sprite (background rotation/scaling
is relative to the upper left). Starting with sprite 0 and repeating every =
4 sprites, they appear in the following
order:


</p><blockquote>
	<p><br>
	<a name=3D"Sprite 0, Attribute 3 - DX/PA"></a><b>Sprite 0, Attribute 3 - P=
A (DX):</b><br>
	Scales the sprite in the x direction by an amount equal to 1/(register val=
ue). Thus, a value of 1.0 results in
	the original image size, while a value of 2 is half as large, and a value =
of .5 is twice as large.<br>
	<br>
	<a name=3D"Sprite 1, Attribute 3 - DMX/PB"></a><b>Sprite 1, Attribute 3 - =
PB (DMX)</b>:<br>
	Shears the x coordinates of the sprite over y. A value of 0 will result in=
 no shearing, a value of 1.00 will make
	the image appear to be sheared left going down the screen, and a value of =
-1 will make the image appear sheared
	right going down the screen.<br>
	<br>
	<a name=3D"Sprite 2, Attribute 3 - DY/PC"></a><b>Sprite 2, Attribute 3 - P=
C (DY)</b>:<br>
	Shears the y coordinates of the sprite over x. A value of 0 will result in=
 no shearing, a value of 1.00 will make
	the image appear to be sheared upwards to the right, and a value of -1 wil=
l make the image appear sheared downwards
	and to the right.<br>
	<br>
	<a name=3D"Sprite 3, Attribute 3 - DMY/PD"></a><b>Sprite 3, Attribute 3 - =
PD (DMY)</b>:<br>
	Scales the image in the y direction by an amount equal to 1/(register valu=
e). Thus, a value of 1.0 results in the
	original image size, while a value of 2 is half as large, and a value of .=
5 is twice as large.</p>

</blockquote>

<p>
</p><h3><b>To Make a Sprite Rotate and Scale: (Taken from PERN Tutorial Day=
 3)</b></h3>
<p>The basic form of the equations for rotating and scaling is as follows:


</p><blockquote>
	<p>pa =3D x_scale * cos(angle);<br>
	pb =3D y_scale * sin(angle);<br>
	pc =3D x_scale * -sin(angle);<br>
	pd =3D y_scale * cos(angle);</p>

</blockquote>

<h3><br>
<a name=3D"Sprite Tile Data"></a><b>Sprite Tile Data</b></h3>
<p>The tile data area contains the actual bitmap for each tile. The sprites=
 do not share tile data with the BG
layers as on the Gameboy Color. The sprite tile data starts at 0x06010000. =
All tiles are 8x8 pixels large. Sprites
use the second <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpe=
c.htm#Palette">palette</a> which begins
at 0x05000200. For 256 color sprites, there are 64 bytes per tile, one byte=
 per pixel. This is an 8-bit value which
is an index into the 256 color palette. For 16-color sprites, <a href=3D"ht=
tp://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Attribute%202">attribu=
te
2</a> (bytes 5 and 6) of the OAM data contains a 4 bit index into 16 16 col=
or palettes, and sprites have 32 bytes
per tile, with 4 bits per pixel. Note that the tile index references 32 byt=
es at a time, so in the case of 256
color sprite tiles, you will want to set your tile number to reference ever=
 other index (i.e. 0, 2, 4, 6, etc.).
Another thing to note is that in the bitmapped modes (3-5) the memory requi=
red to hold background data is larger
than 0x10000 bytes, forcing the GBA to cut away from available sprite tile =
data. Thus in these modes you may only
reference sprites tiles of indices 512 and up.<br>
<br>
When the sprite is larger than 8x8 pixels, multiple tiles are glued togethe=
r to make the sprite's width horizontally,
and then vertically. How this is done depends on whether character data is =
stored in 2d or 1d mode (determined
by bit 6 of <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.h=
tm#REG_DISPCNT">DISPCNT</a>).


</p><blockquote>
	<p><br>
	<a name=3D"1D Mapping"></a><b>1D Mapping:</b> <br>
	In 1D mode, tiles are stored sequentially. If you were to set up a 32x32 1=
6-color sprite, and set the tile number
	to 5, the sprite would be displayed as follows:</p>
	<pre>---------------------
| 5  | 6  | 7  | 8  |
|    |    |    |    |
---------------------
| 9  | 10 | 11 | 12 |
|    |    |    |    |
---------------------
| 13 | 14 | 15 | 16 |
|    |    |    |    |
---------------------
| 17 | 18 | 19 | 20 |
|    |    |    |    |
---------------------</pre>
	<p><br>
	<a name=3D"2D Mapping"></a><b>2D Mapping: </b><br>
	Tiles on each row of the sprite are stored 32 slots in. Using the same 32x=
32 sprite above, with a tile number of
	5, the sprite would be displayed as:</p>
	<pre>---------------------
| 5  | 6  | 7  | 8  |
|    |    |    |    |
---------------------
| 37 | 38 | 39 | 40 |
|    |    |    |    |
---------------------
| 69 | 70 | 71 | 72 |
|    |    |    |    |
---------------------
| 101| 102| 103| 104|
|    |    |    |    |
---------------------</pre>

</blockquote>

<p>
</p><h2>7. <a name=3D"Windowing"></a>Windowing<br>

<hr align=3D"CENTER">
</h2>
<p>Windowing is a method of dividing the screen into subsections known as (=
surprise) windows. The windows serve
as boundary areas to determine where various layers of the GBA will be show=
n and where they will be clipped. There
are two primary windows, win0 and win1, which can be enabled in <a href=3D"=
http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_DISPCNT">REG_DIS=
PCNT</a>.
There is also the "obj" window, which can be thought of as another window w=
hich is defined by the visible
regions of the objs on screen. Finally there is the "outside" or "out" wind=
ow - the area of
the screen not already occupied by any other winodw. The position and size =
of WIN0 and WIN1 are determined by <a href=3D"http://www.cs.rit.edu/~tjh830=
0/CowBite/CowBiteSpec.htm#REG_WIN0_H">REG_WIN0H</a>, <a href=3D"http://www.=
cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_WIN1_H">REG_WIN1H</a>,
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_WIN0_=
V">REG_WIN0V</a>, and <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Cow=
BiteSpec.htm#REG_WIN1_V">REG_WIN1V</a>
(I/O offsets 0x40, 0x42, 0x44, 0x46). Exactly which characters and backgrou=
nds appear within or without win0, win1,
and the obj window is determined by <a href=3D"http://www.cs.rit.edu/~tjh83=
00/CowBite/CowBiteSpec.htm#REG_WIN_IN">REG_WININ</a>
and <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_W=
IN_OUT">REG_WINOUT</a> (0x48 and 0x4A).
<br>
<br>
Here are some things to keep in mind when using windows :


</p><blockquote>
	<p>- WIN0 and WIN1 are drawn from the left and top boundary up to but not =
including the right and bottom boundaries.<br>
	- Everything in WIN0 appears "above" WIN1 (i.e. it has higher priority), a=
nd everything in windows 0
	&amp; 1 appears above the WINOUT and obj windows.<br>
	- If a bg or the obj's are turned off in dispcnt, they're off in all windo=
ws regardless of the settings in win_in
	and win_out.<br>
	- If only one window is on, WINOUT affects everything outside of it (if bo=
th windows are on, WINOUT affects everything
	outside both of them. IE, it affects (!WIN0)&amp;&amp;(!WIN1) ).<br>
	- If a window is on, but the effective display bits are all clear, the bac=
kdrop is displayed.<br>
	- If the window left coordinate is greater than the window right coordinat=
e, the window will be drawn outside of
	this region (i.e. to the left and to the right) rather than in the area in=
between.<br>
	- Likewise, if the window top coordinate is greater than the window bottom=
 coordinate, the window will be drawn
	to the top and the bottom.<br>
	- A completely inverted window is drawn in the area outside of the "+" sha=
ped region defined by its boundaries.</p>

</blockquote>

<p>Windows can be used in console games for a variety of different effects.=
 Though the window registers define
a square region, differently shaped windows can be achieved by using <a hre=
f=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_DMA0CNT">hd=
ma</a>
or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Hardwa=
re%20Interrupts">hblank interrupts</a> to
change the parameters each scanline. Lantern lighting (when the hero has a =
lantern or flashlight that illuminates
a certain region of a cave) and x-ray vision (use of the window to cut away=
 layers that are in front) are two common
effects created with windows. More are certainly possible.<br>
<br>
Thanks again to gbcft for most of these notes and for his extensive testing=
 on the nature of windowing.
</p><h2><br>
8. <a name=3D"Hardware Interrupts"></a>Hardware Interrupts<br>

<hr align=3D"CENTER">
</h2>
<p>Figuring out hardware interrupts was kind of painful. Everything below i=
s what I have gleaned from reading <a href=3D"http://www.arm.com/">ARM's do=
cs</a>, the list, the advice of other emulator and demo authors, and from v=
arious
other emulator's debug info. I hope it is of some use to you. Let me know i=
f you find any errors or typos.<br>
<br>
<b>Key points: </b><br>
- All hardware interrupt vectors lie in the BIOS. You cannot handle interru=
pts directly, you must go through the
BIOS. Thus, the instructions for exception handling in the ARM docs do not =
apply directly since we cannot handle
the exceptions directly. <br>
<br>
- Interrupts are enabled by setting the flags in the <a href=3D"http://www.=
cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_IE">REG_IE</a>
and hardware registers like <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBi=
te/CowBiteSpec.htm#REG_STAT">REG_DISPSTAT</a>,
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_KEYCN=
T">REG_KEYCNT</a>, and <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Co=
wBiteSpec.htm#DMA%20Control%20Registers">REG_DMAXCNT</a>.
The flag must be set in both REG_IE and the corresponding hardware register=
 for it to work. When the interrupt
signal is sent, the appropriate flag is set in <a href=3D"http://www.cs.rit=
.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_IF">REG_IF</a>.
The program code unsets this flag (by writing a 1 to that bit) in order to =
keep track of what interrupts have been
handled. <br>
<br>
<b>- When an interrupt occurs, the CPU does the following:</b>


</p><blockquote>
	<p>1. Switches state to IRQ mode, bank-swaps the current stack register an=
d link register (thus preserving their
	old values), saves the CPSR in SPSR_irq, and sets bit 7 (interrupt disable=
) in the CPSR. <br>
	2. Saves the address of the next instruction in LR_irq compensating for Th=
umb/ARM depending on the mode you are
	in. <br>
	3. Switches to <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSp=
ec.htm#ARM%20State">ARM state</a>, executes
	code in BIOS at a hardware interrupt vector (which you, the programmer, ne=
ver see)</p>

</blockquote>

<p><b>- The BIOS code picks up at the hardware interrupt vector and does th=
e following:</b>


</p><blockquote>
	<p>4. Pushes registers 0 - 3, 12, LR_irq (which cointains the address foll=
owing the instruction when the interrupt
	occrued) onto the stack <br>
	5. Places the address for the next instruction (in the BIOS, not in your c=
ode) in LR <br>
	6. Loads the address found at 0x03007FFC <br>
	7. Branches to that address.</p>

</blockquote>

<p><b>- The program code at that address is executed.</b>


</p><blockquote>
	<p>8. It is the responsiblity of the code at that address to return once f=
inished, <br>
	using BX LR_irq</p>

</blockquote>

<p><b>- The BIOS finishes up where your code leaves off:</b>


</p><blockquote>
	<p>9. It restores registers 0 - 3, 12, LR_irq <br>
	10. Branches to the intruction found in LR, using a SUBS PC, LR_irq, #4</p=
>

</blockquote>

<p><b>- Upon receiving the SUBS PC, LR_irq, #4 instruction, the CPU</b>


</p><blockquote>
	<p>11. Copies the SPSR_irq back into the CPSR, restoring the status bits t=
o their <br>
	state when the interrupt occurred, and bank swaps back in the stack regist=
er <br>
	and link register. The CPU will thus be placed in the correct state (<a hr=
ef=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#ARM%20State">A=
RM</a>
	or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Thumb=
%20State">Thumb</a>) <br>
	it was in when the exception occurred.</p>

</blockquote>

<p><br>
So, the basic model for setting up interrupts is: <br>
<br>
1. Place the address for your interrupt code at 0x03007FFC. <br>
<br>
2. Turn on the interrupts you wish to use:<br>
- <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_STA=
T">REG_DISPSTAT</a>, <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowB=
iteSpec.htm#REG_TM0CNT">REG_TMXCNT</a>,
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_KEYCN=
T">REG_KEYCNT</a>, or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Cow=
BiteSpec.htm#REG_DMA0CNT">REG_DMAXCNT</a>
tell the hardware which interrupts to send<br>
- 0x04000200 (<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec=
.htm#REG_IE">REG_IE</a>) masks which interrupts
will actually be serviced (?) <br>
- 0x04000208 (<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec=
.htm#REG_IME">REG_IME</a>) Turns all interrupts
on or off. <br>
<br>
3. When the interrupt is reached, the code at the address at 0x3007FFC gets=
 loaded into the CPU. To prevent unwanted
errors/behavior, the first thing this code should do is disable interrupts.=
<br>
<br>
4. To determine what interrupt this is, check the flags in 0x04000202 (<a h=
ref=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_IF">REG_I=
F</a>).
Unset the flag by writing a 1 to that bit.<br>
<br>
5. Once finished with the service routine, reenable interrupts and execute =
a BX LR (*Not* a SUBS PC, LR #4, which
is what the BIOS does). The BIOS will then take over and return your progra=
m to where execution left off.
</p><h3><br>
<a name=3D"Types of Hardware Interrupts"></a>Types of Hardware Interrupts</=
h3>
<p>Enable these interrupts using <a href=3D"http://www.cs.rit.edu/~tjh8300/=
CowBite/CowBiteSpec.htm#REG_STAT">REG_DISPSTAT</a>,
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_TM0CN=
T">REG_TMXCNT</a>, <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBit=
eSpec.htm#REG_KEYCNT">REG_KEYCNT</a>,
or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_DM=
A0CNT">REG_DMAXCNT</a>, then setting the
correct flags in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteS=
pec.htm#REG_IE">REG_IE</a> and <a href=3D"http://www.cs.rit.edu/~tjh8300/Co=
wBite/CowBiteSpec.htm#REG_IME">REG_IME</a>.<br>
<br>
V-Blank: Occurs when the <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/=
CowBiteSpec.htm#REG_VCOUNT">vcount</a>
reaches 160, or 0xA0. (Enable in <a href=3D"http://www.cs.rit.edu/~tjh8300/=
CowBite/CowBiteSpec.htm#REG_STAT">REG_DISPSTAT</a>)<br>
<br>
H-Blank: Occurs at the end of every raster line, from 0 - 228. H-blank inte=
rrupts DO occur during v-blank (unlike
hdma, which does not), so write your code accordingly. Thanks to gbcft for =
verifying this. (Enable in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBit=
e/CowBiteSpec.htm#REG_STAT">REG_DISPSTAT</a>)
<br>
<br>
Serial: I am unsure about this; I presume it has to do with the link cable.=
 <br>
<br>
V-Count: Occurs when the <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/=
CowBiteSpec.htm#REG_VCOUNT">vcount</a>
reaches the number specified in <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#REG_STAT">REG_DISPSTAT</a>.
<br>
<br>
Timer: These occur whenever one of the <a href=3D"http://www.cs.rit.edu/~tj=
h8300/CowBite/CowBiteSpec.htm#Timer%20registers">timer
registers</a> is set to cause an interrupt whenever it overflows. Enable in=
 <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_TM0C=
NT">REG_TMXCNT</a>.<br>
<br>
DMA: These occur after a DMA transfer, according to the flags in the <a hre=
f=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#DMA%20Control%2=
0Registers">DMA_CNT</a>
registers and in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteS=
pec.htm#REG_IE">REG_IE</a>. Enable in
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_DMA0C=
NT">REG_DMAXCNT</a>.<br>
<br>
Key: Occurs when the user presses or releases the buttons specified in <a h=
ref=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_KEYCNT">R=
EG_KEYCNT</a>.<br>
<br>
Cassette: Occurs when the user yanks out or inserts the cartridge out while=
 the GBA is still running. For a cartridge
interrupt to work properly the ISR must reside in RAM. It is possible to sw=
itch cartridges and have the routine
resume execution on a completely different ROM.
</p><h2><br>
9. <a name=3D"BIOS (Software Interrupts)"></a>BIOS (Software Interrupts - p=
artially implemented in CowBite)<br>

<hr align=3D"CENTER">
</h2>
<p>The BIOS calls are basically SWI instructions; the value passed into the=
 instruction tells the CPU which interrupt
to execute. <br>
The most significant portions of this section come from Martin Korth's very=
 detailed description of the BIOS functions
in his <a href=3D"http://www.work.de/nocash/gba.htm">no$gba</a> documentati=
on. Thanks also to Forgotten's call list
to his <a href=3D"http://vboy.emuhq.com/faq.shtml">Visual Boy Advance FAQ</=
a>.<br>
<br>
Note that the BIOS SWI handler does not perform range checking, so calling =
SWI 43 - 255 (0x2B - 0xFF) will cause
a lock up.<br>
<br>
<font size=3D"2">0x00: SoftReset</font>


</p><blockquote>
	<p><font size=3D"2">Resets the GBA and runs the code at address 0x2000000 =
or 0x8000000 depending on the contents
	of 0x3007ffa (0 means 0x8000000 and anything else means 0x2000000).</font>=
</p>

</blockquote>

<p><font size=3D"2">0x01: RegisterRamReset</font>


</p><blockquote>
	<p><font size=3D"2">Performs a selective reset of memory and I/O registers=
.<br>
	Input: r0 =3D reset flags</font></p>

</blockquote>

<p><font size=3D"2">0x02: Halt</font>


</p><blockquote>
	<p><font size=3D"2">Halts CPU execution until an interrupt occurs.</font><=
/p>

</blockquote>

<p><font size=3D"2">0x03: Stop</font>


</p><blockquote>
	<p><font size=3D"2">Stops the CPU and LCD until the enabled interrupt (key=
pad, cartridge or serial) occurs.</font></p>

</blockquote>

<p><font size=3D"2">0x04: IntrWait</font>


</p><blockquote>
	<p><font size=3D"2">Waits for the given interrupt to happen.<br>
	Input: r0 =3D initial flag clear, r1 =3D interrupt to wait</font></p>

</blockquote>

<p><font size=3D"2">0x05: VBlankIntrWait</font>


</p><blockquote>
	<p><font size=3D"2">Waits for vblank to occur. Waits based on interrupt ra=
ther than polling in order to save battery
	power.<br>
	Equivalent of calling IntrWait with r0=3D1 and r1=3D1.</font></p>

</blockquote>

<p><font size=3D"2">0x06: Div</font>


</p><blockquote>
	<p><font size=3D"2">Input: r0 =3D numerator, r1 =3D denominator <br>
	Output: r0 =3D numerator/denominator <br>
	r1 =3D numerator % denominator; <br>
	r3 =3D abs (numerator/denominator)</font></p>

</blockquote>

<p><font size=3D"2">0x07: DivArm</font>


</p><blockquote>
	<p><font size=3D"2">Input: r0 =3D denominator, r1 =3D numerator<br>
	Output: r0 =3D numerator/denominator <br>
	r1 =3D numerator % denominator; <br>
	r3 =3D abs (numerator/denominator)<br>
	Note: For compatibility with ARM's library only. Slightly slower than SWI =
6.</font></p>

</blockquote>

<p><font size=3D"2">0x08: Sqrt</font>


</p><blockquote>
	<p><font size=3D"2">Input: r0 =3D unsigned 32-bit number <br>
	Output: r0 =3D sqrt(number) (unsigned 32-bit integer)</font></p>

</blockquote>

<p><font size=3D"2">0x09: ArcTan</font>


</p><blockquote>
	<p><font size=3D"2">Input: r0 =3D Tangent(angle) (16-bit; 1 bit sign, 1 bi=
t integral, 14 bit decimal)<br>
	Output: r0 =3D "-PI/2&lt;THETA/&lt;PI/2" in a range of 0xC000h-0x4000.<br>
	Note: There is a problem in accuracy with "THETA&lt;-PI/4, PI/4&lt;THETA"<=
/font></p>

</blockquote>

<p><font size=3D"2">0x0A: ArcTan2</font>


</p><blockquote>
	<p><font size=3D"2">Note: I'm unsure about this one, since there is confli=
cting info about its purpose, and I have
	not tested it.<br>
	Version 1:<br>
	Calculates the arctangent of the given point.<br>
	Input: r0 =3D X (signed 16-bit), r1 =3D Y (signed 16-bit)<br>
	Output: r0=3Darctan<br>
	<br>
	Version 2:<br>
	Calculates the arctangent after correction processing.<br>
	Input: r0 =3D Tangent(angle) (16-bit; 1 bit sign, 1 bit integral, 14 bit d=
ecimal)<br>
	Output: r0 =3D 0000h-FFFFh for 0&lt;=3DTHETA&lt;2PI</font></p>

</blockquote>

<p><font size=3D"2"><br>
0x0B: CPUSet</font>


</p><blockquote>
	<p><font size=3D"2">Performs a memory transfer.<br>
	Input: r0 =3D source address, r1 =3D dest address <br>
	r2 =3D Length and mode:<br>
	bit 24 =3D Fixed source address (0 - copy, 1 =3D set with word at r0)<br>
	bit 26 =3D 32 or 16 bit transfer <br>
	bits 15 - 0 =3D number of transfers</font></p>

</blockquote>

<p><font size=3D"2">0x0C: CPUFastSet</font>


</p><blockquote>
	<p><font size=3D"2">Also performs a memory transfer, in 32-byte blocks, us=
ing LDMIA/STMIA instructions<br>
	Performs a memory transfer.<br>
	Input: r0 =3D source address, r1 =3D dest address <br>
	r2 =3D Length and mode:<br>
	bit 24 =3D Fixed source address (0 - copy, 1 =3D set with word at r0)<br>
	bits 15 - 0 =3D number of transfers</font></p>

</blockquote>

<p><font size=3D"2">0x0D: BiosChecksum</font>


</p><blockquote>
	<p><font size=3D"2">Calculates the checksum of the whole BIOS by adding ev=
ery 32-bit word from the BIOS.<br>
	Output: r0 =3D BIOS checksum<br>
	Note: this seems to only be present in the release version of the BIOS</fo=
nt></p>

</blockquote>

<p><font size=3D"2">0x0E: BgAffineSet</font>


</p><blockquote>
	<p><font size=3D"2">Calculates the affine parameters for bgs (rotation and=
 scaling).<br>
	Input: r0 =3D source, r1 =3D dest, r2 =3D number of calculations<br>
	<br>
	Where the data at the source is an array of r2 structures of the format:</=
font></p>
	<pre><font size=3D"2">typdef struct tBGAffineSource {
     s32 x;     //Original data's center X coordinate (8bit fractional port=
ion)
     s32 y;     //Original data's center Y coordinate (8bit fractional port=
ion)
     s16 tX;    //Display's center X coordinate
     s16 tY;    //Display's center Y coordinate
     s16 sX;    //Scaling ratio in X direction (8bit fractional portion)
     s16 sY;    //Scaling ratio in Y direction (8bit fractional portion)
     u16 theta; //Angle of rotation (8bit fractional portion) Effective Ran=
ge 0-FFFF
} BGAffineSource;</font></pre>

	<blockquote>
		<p>

	</p></blockquote>
	<p><font size=3D"2">And the return data (placed at the dest address) will =
be of the format:</font></p>
	<pre><font size=3D"2">typdef struct tBGAffineDest {
     s16 pa;  //Difference in X coordinate along same line
     s16 pb;  //Difference in X coordinate along next line
     s16 pc;  //Difference in Y coordinate along same line
     s16 pd;  //Difference in Y coordinate along next line
     s32 x;   //Start X coordinate
     s32 y;   //Start Y coordinate
} BGAffineDest;</font></pre>
	<p><font size=3D"2"><br>
	(from no$gba docs)</font></p>

</blockquote>

<p><font size=3D"2">0x0F: ObjAffineSet</font>


</p><blockquote>
	<p><font size=3D"2">Calculates and sets the OBJ's affine parameters from t=
he scaling ratio and angle of rotation.<br>
	The four affine parameters are set every offset bytes, starting from the d=
est pointer address.<br>
	If the offset value is 2, the parameters are stored contiguously. If the v=
alue is 8, they match the structure of
	OAM.<br>
	<br>
	Input: r0 =3D source, r1 =3D dest, r2 =3D number of calculations, r3 =3D O=
ffset in bytes for parameter addresses (2=3Dcontigiously,
	8=3DOAM)<br>
	Where the data at the source address is of the format:</font></p>
	<pre><font size=3D"2">typedef struct tObjAffineSource {
     s16 sX;    //Scaling ratio in X direction (8bit fractional portion)
     s16 sY;    //Scaling ratio in Y direction (8bit fractional portion)
     u16 theta;     //Angle of rotation (8bit fractional portion) Effective=
 Range 0-FFFF
} ObjAffineSource;</font></pre>
	<p><font size=3D"2"><br>
	And the data at the destination address is of the format:</font></p>
	<pre><font size=3D"2">typedef struct tObjAffineDest {
     s16 pa;  //Difference in X coordinate along same line
     s16 pb;  //Difference in X coordinate along next line
     s16 pc;  //Difference in Y coordinate along same line
     s16 pd;  //Difference in Y coordinate along next line
} ObjAffineDest;</font></pre>
	<p>

</p></blockquote>

<p><font size=3D"2">0x10: BitUnPack</font>


</p><blockquote>
	<p><font size=3D"2">Unpacks bit packed data.<br>
	Input: r0 =3D source, r1 =3D dest, r2 =3D pointer to unpack parameters<br>
	<br>
	Where the unpack parameters are of the format:</font></p>
	<pre><font size=3D"2">typedef struct tBUP {
    u16 sourceLength;     //Length of Source Data in bytes (0-0xFFFF)
    u8 sourceWidth;       //Width of Source Units in bits (only 1,2,4,8 sup=
ported)
    u8 destWidth;         //Width of Destination Units in bits (only 1,2,4,=
8,16,32 supported)
    u32 destOffset;       //31-bit Data Offset (Bit 0-30), and Zero Data Fl=
ag (Bit 31)
} BUP;</font></pre>
	<p><font size=3D"2"><br>
	The Data Offset is always added to all non-zero source units.<br>
	If the Zero Data Flag was set, it is also added to zero units.<br>
	<br>
	Data is written in 32-bit units, Destination can be Wram or Vram. The size=
 of unpacked data must be a multiple
	of 4 bytes. The width of source units (plus the offset) should not exceed =
the destination width.</font></p>

</blockquote>

<p><font size=3D"2">0x11: LZ77UnCompWRAM</font>


</p><blockquote>
	<p><font size=3D"2">Uncompresses LZSS data 8 bits at a time<br>
	Input: r0 =3D source address, r1 =3D dest address</font></p>

</blockquote>

<p><font size=3D"2">0x12: LZ77UnCompVRAM</font>


</p><blockquote>
	<p><font size=3D"2">Uncompresses LZSS data 16 bits at a time<br>
	Input: r0 =3D source address, r1 =3D dest address<br>
	<br>
	</font><font size=3D"1">Note: The LZ77 decompressors actually decompress L=
ZSS, not LZ77, which is slightly different.
	You will have to look on the web to find the algorithm as it is beyond the=
 scope of this document. The following
	assumes a general famliarity with LZSS. <br>
	<br>
	On the GBA, the ring buffer or "window" is of size 4096, the minumim compr=
essed length is 3 and the maximum
	compressed length is 18. Looking into a compressed buffer you will find th=
e size of the uncompressed memory in
	bytes 2, 3, and 4 (I'm not sure what the first byte does, but it seems to =
always be set to "01"), followed
	by the coded data. This is divided up into sections consisting of an 8 bit=
 key followed by a corresponding eight
	items of varying size. The upper bits in the key correspond to the items w=
ith lower addresses and vice versa. For
	each bit set in the key, the corresponding item will be 16 bits; the top b=
its four being the number of bytes to
	output, minus 3, and the bottom sixteen bits being the offset behind the c=
urrent window position from which to
	output. For each bit which is not set, the corresponding item is an uncomp=
ressed byte and gets sent to the output.<br>
	<br>
	Thanks to Markus for providing me with some source that helped me figure o=
ut all of this.</font></p>

</blockquote>

<p><font size=3D"2"><br>
0x13: HuffUnComp</font>


</p><blockquote>
	<p><font size=3D"2">Unpacks data compressed with Huffman and writes it 32-=
bits at a time.<br>
	Input: r0 =3D source address, r1 =3D dest address<br>
	Where the data at the source address is of the format:<br>
	<br>
	Data Header (32bit)<br>
	Bit 0-3 Data size in bit units (normally 4 or 8)<br>
	Bit 4-7 Compressed type (must be 2 for Huffman)<br>
	Bit 8-31 24bit size of decompressed data in bytes<br>
	<br>
	Tree Table<br>
	u8 tree table size/2-1<br>
	<br>
	Each of the nodes below defined as:</font></p>
	<pre><font size=3D"2">7 6 5 3 3 2 1 0
</font><font size=3D"2" color=3D"#008800">L</font><font size=3D"2"> </font>=
<font size=3D"2" color=3D"#0000DD">R</font><font size=3D"2"> </font><font s=
ize=3D"2" color=3D"#FF0099">O O O O O O</font></pre>
	<p><font size=3D"2">0 - 5 (O) =3D offset to next node -1 (2 byte units)<br=
>
	6 (R) =3D Right node end flag (if set, data is in next node)<br>
	7 (L) =3D Left node end flag<br>
	<br>
	1 node Root node<br>
	2 nodes Left, and Right node<br>
	4 nodes LeftLeft, LeftRight, RightLeft, and RightRight node<br>
	- Compressed data</font></p>

</blockquote>

<p><font size=3D"2">0x14: RLUnCompWRAM</font>


</p><blockquote>
	<p><font size=3D"2">Uncompresses RLE data 8 bits at a time<br>
	Input: r0 =3D source address, r1 =3D dest address</font></p>

</blockquote>

<p><font size=3D"2">0x15: RLUnCompVRAM</font>


</p><blockquote>
	<p><font size=3D"2">Uncompresses RLE data 16 bits at a time (slower)<br>
	Input: r0 =3D source address, r1 =3D dest address<br>
	<br>
	The data at the source address for both RLU functions is of the format:<br=
>
	Data header (32-bit)<br>
	Bit 0-3 Reserved<br>
	Bit 4-7 Compressed type (must be 3 for run-length)<br>
	Bit 8-31 Size of decompressed data<br>
	<br>
	Repeat below. Each Flag Byte followed by one or more Data Bytes. Flag data=
 (8bit)<br>
	Bit 0-6 Expanded Data Length (uncompressed N-1, compressed N-3)<br>
	Bit 7 Flag (0=3Duncompressed, 1=3Dcompressed)<br>
	<br>
	Data Byte(s) - N uncompressed bytes, or 1 byte repeated N times</font></p>

</blockquote>

<p><font size=3D"2"><br>
0x16: Diff8bitUnFilterWRAM</font>


</p><blockquote>
	<p><font size=3D"2">Unpacks data filtered with 8-bit difference and writes=
 it 8-bits at a time.<br>
	Input: r0 =3D source, r1 =3D dest</font></p>

</blockquote>

<p><font size=3D"2"><br>
0x17: Diff8bitUnFilterVRAM</font>


</p><blockquote>
	<p><font size=3D"2">Unpacks data filtered with 8-bit difference and writes=
 it 16-bits at a time.<br>
	Input: r0 =3D source, r1 =3D dest</font></p>

</blockquote>

<p><font size=3D"2">0x18: Diff16bitUnFilter</font>


</p><blockquote>
	<p><font size=3D"2">Unpacks data filtered with 16-bit difference and write=
s it 16-bits at a time.<br>
	Input: r0 =3D source, r1 =3D dest<br>
	<br>
	In each UnFilter function the format of the dest is:<br>
	Data Header (32-bit)<br>
	Bit 0-3 Data size (must be 1 for Diff8bit, 2 for Diff16bit)<br>
	Bit 4-7 Type (must be 8 for DiffFiltered)<br>
	Bit 8-31 24bit size after decompression<br>
	<br>
	Data Units (each 8bit or 16bit depending on used SWI function)<br>
	Data0 //original data<br>
	Data1-Data0 //difference data<br>
	Data2-Data1 <br>
	Data3-Data2</font></p>

</blockquote>

<p><font size=3D"2">0x19: SoundBiasChange</font>


</p><blockquote>
	<p><font size=3D"2">Sets the sound bias from 0 to 0x200 or from 0x200 to 0=
 depending on the value of R0.<br>
	Input: r0 =3D 0 to set it to 0, other values to set it to 0x200</font></p>

</blockquote>

<p><font size=3D"2">0x1A: SoundDriverInit</font>


</p><blockquote>
	<p><font size=3D"2">Initializes the built in sound driver. Do not initiali=
ze more than once.<br>
	Input: r0 =3D SoundArea<br>
	<br>
	Note: This has been abridged from the description in the</font><font size=
=3D"1"> </font><a href=3D"http://www.work.de/nocash/gba.htm"><font size=3D"=
2">no$gba</font></a><font size=3D"2"> documentation. I suggest checking the=
re for a more thorough description.<br>
	<br>
	The SoundArea Structure has the following format:</font></p>
	<pre><font size=3D"2">typedef struct tSoundArea {
</font>     u32 ident;           //Flag the system checks to see if the wor=
k area has been
                          //initialized/currently being accessed.
     vu8 DmaCount;        //User access prohibited
     u8  reverb;          //Variable for applying reverb effects to direct =
sound
     u16 d1;              //User access prohibited
     void (*func)();      //User access prohibited
     int intp;            //User access prohibited
     void* NoUse;         //User access prohibited
     SoundChannel vchn[MAX];     //Array of Direct Sound channel structures=
.
     s8 pcmbuf[PCM_BF*2]; //??
} SoundArea;

typedef struct tSoundChannel {
     u8 sf;     //Channel status.  When 0 sound it is stopped.  To start so=
und, set other=20
                //parameters and then write 0x80h.  Logical OR 0x40 for a k=
ey-off, or
                //write zero for a pause. The use of other bits is prohibit=
ed.
     u8 r1;     //User access prohibited
     u8 rv;     //Sound volume output to right side
     u8 lv;     //Sound volume output to left side
     u8 at;     //The attack value of the envelope.
     u8 de;     //The decay value of the envelope.
     u8 su;     //The sustain value of the envelope.
     u8 re;     //The release value of the envelope. Key-off to enter this =
state.
     u8 r2[4];  //User access prohibited
     u32 fr;    //The frequency of the produced sound.
     WaveData*  wp;     //Pointer to the sound's waveform data.
     u32 r3[6];  //  User access prohibited
     u8 r4[4];   //User access prohibited
} SoundChannel;

typedef struct tWaveData {
     u16 type;   //Indicates the data type. This is currently not used.
     u16 stat;   //0 - non-looped 0x4000 - forward loop
     u32 freq;   //Frequency.
     u32 loop;   //Loop pointer (start of loop)
     u32 size;   //Number of samples (end position)
     s8 data[];  //The actual waveform data. Takes (number of samples+1)byt=
es of 8bit=20
                 //signed linear uncompressed data. The last byte is zero f=
or a non-looped
                 //waveform, and the same value as the loop pointer data fo=
r a looped waveform.
} WaveData;
</pre>

</blockquote>

<p><font size=3D"2">0x1B: SoundDriverMode</font>


</p><blockquote>
	<p><font size=3D"2">Sets the operation of the built in sound driver.<br>
	Input: r0 =3D operation mode</font></p>
	<pre>31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  11 1=
0 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X  X  X  X  </font><font color=3D"#777777"> </font>=
<font color=3D"#FF3300">R  R  R  R   </font><font color=3D"#FF0099">R  R  R=
  R </font><font color=3D"#FF3300">  F  F  F  F   </font><font color=3D"#99=
00CC">V  V  V  V  </font><font color=3D"#FF3300"> </font><font color=3D"#00=
99FF">C  C  C C</font><font color=3D"#00CCFF"> </font><font color=3D"#00880=
0"> S </font><font color=3D"#FF0099">R R R  R R R R

</font>0-6 <font color=3D"#FF0099">  (R)</font> =3D Direct Sound Reverb val=
ue (0-127, default=3D0) (ignored if Bit7=3D0)
7   <font color=3D"#008800">  (S)</font> =3D Direct Sound Reverb set (0=3Di=
gnore, 1=3Dapply reverb value)
8-11 <font color=3D"#0099FF"> (C)</font> =3D Direct Sound Simultaneously-pr=
oduced (1-12 channels, default 8)
12-15 <font color=3D"#9900CC">(V)</font> =3D Direct Sound Master volume (1-=
15, default 15)
16-19 <font color=3D"#FF3300">(F)</font> =3D Direct Sound Playback Frequenc=
y (1-12 =3D 5734,7884,10512,13379,
                                             15768,18157,21024,26758,31536,
                                             36314,40137,42048, def 4=3D133=
79 Hz)
20-23 <font color=3D"#FF0099">(D)</font> =3D Final number of D/A converter =
bits (8-11 =3D 9-6bits, def. 9=3D8bits)</pre>
	<p>

</p></blockquote>

<p><font size=3D"2">0x1C: SoundDriverMain</font>


</p><blockquote>
	<p><font size=3D"2">Main function of the built in sound driver that is cal=
led by applications after SoundDriverVSync
	to render the sound. Does not have to be called at a precise 60hz interval=
, but must be called once during every
	60hz period.</font></p>

</blockquote>

<p><font size=3D"2">0x1D: SoundDriverVSync</font>


</p><blockquote>
	<p><font size=3D"2">Call this function at the very start of vblank (or, pr=
esumably, any other 60hz increment) to
	sync the BIOS sound driver.</font></p>

</blockquote>

<p><font size=3D"2">0x1E: SoundChannelClear <br>
0x1F: MIDIKey2Freq <br>
Ox20: MusicPlayerOpen <br>
0x21: MusicPlayerStart <br>
0x22: MusicPlayerStop <br>
0x23: MusicPlayerContinue <br>
0x24: MusicPlayerFadeOut <br>
0x25: MultiBoot <br>
0x26: HardReset (Undocumented)<br>
0x27: CustomHalt (Undocumented)<br>
0x28: SoundDriverVSyncOff</font>


</p><blockquote>
	<p><font size=3D"2">Call this function in the event that the SoundDriverVS=
ync function misses the 60hz interval (for
	example, when loading new data at the beginning of a stage).. It will keep=
 the sound DMA from overflowing and playing
	noise.</font></p>

</blockquote>

<p><font size=3D"2">0x29: SoundDriverVSyncOn</font>


</p><blockquote>
	<p><font size=3D"2">Call this after calling SoundDriverVSyncOff, to restor=
e sound driver operation.</font></p>

</blockquote>

<p><font size=3D"2">0x2A: GetJumpList (for sound?) (Undocumented)<br>
<br>
<br>
?: FIQMasterEnable</font>
</p><h2><br>
<br>
10. <a name=3D"Memory-Mapped Hardware Registers"></a>Memory-Mapped Hardware=
 Registers</h2>
<p>The following section describes the function of each of the memory-mappe=
d addresses in IO RAM. The register
naming scheme is based on a variant of the popular <a href=3D"http://www.cs=
.rit.edu/~tjh8300/CowBite/gba.h">gba.h</a>
by Eloist (specifically, that used by Uze in the examples on his Audio Adva=
nce site).<br>
<br>
The notation for each entry is as follows:</p>
<pre>                           <font color=3D"#FF0000">R</font>  <font col=
or=3D"#777777">&lt;- </font>'<font color=3D"#FF0000">R</font>' <font color=
=3D"#555555">means "Read Only", '</font><font color=3D"#CC9900">W</font><fo=
nt color=3D"#555555">' means "Write Only"</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0   <font color=3D"#555555">&lt;- These ar=
e the bits</font>
<font color=3D"#008800">W</font> <font color=3D"#0099FF">V</font> <font col=
or=3D"#9900CC">U</font> <font color=3D"#FF0099">S</font>  <font color=3D"#F=
F3300">L</font> <font color=3D"#008800">K</font> <font color=3D"#0099FF">J<=
/font> <font color=3D"#9900CC">I</font>  <font color=3D"#FF0099">F</font><f=
ont color=3D"#009999"> </font><font color=3D"#FF3300">D</font> <font color=
=3D"#008800">B</font><font color=3D"#9900CC"> </font><font color=3D"#0099FF=
">A</font><font color=3D"#9900CC">  C</font> <font color=3D"#FF0099">M M M<=
/font>   <font color=3D"#555555">&lt;- These letters are used in the key
                                     Entries marked with an '</font><font c=
olor=3D"#BBBBBB">X</font><font color=3D"#555555">' usually=20
                                     serve no function, are unwriteable,
                                     and remain at 0.</font></pre>
<pre>0-2 <font color=3D"#FF0099">(M)</font>   =3D The video mode. See <a hr=
ef=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Mode%200">vide=
o modes</a> list above. <font color=3D"#555555">&lt;- The key for each bit =
field</font>
</pre>
<h3><br>

<hr align=3D"CENTER">
<b><br>
Addresses: 0x04000000 - 0x4000054 - <a name=3D"Graphics Hardware Registers"=
></a>Graphics Hardware Registers</b></h3>
<p><b><br>
Address: 0x4000000 - <a name=3D"REG_DISPCNT"></a>REG_DISPCNT (The display c=
ontrol register)</b></p>
<pre>                        <font color=3D"#FF0000">   R</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0<font color=3D"#BBBBBB"> </font>
<font color=3D"#008800">W</font> <font color=3D"#0099FF">V</font> <font col=
or=3D"#9900CC">U</font> <font color=3D"#FF0099">S</font>  <font color=3D"#F=
F3300">L</font> <font color=3D"#008800">K</font> <font color=3D"#0099FF">J<=
/font> <font color=3D"#9900CC">I</font>  <font color=3D"#FF0099">F</font><f=
ont color=3D"#009999"> </font><font color=3D"#FF3300">D</font> <font color=
=3D"#008800">B</font><font color=3D"#9900CC"> </font><font color=3D"#0099FF=
">A</font><font color=3D"#9900CC">  C</font> <font color=3D"#FF0099">M M M<=
/font> </pre>
<pre>0-2 <font color=3D"#FF0099">(M)</font> =3D The video mode. See <a href=
=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Mode%200">video =
modes</a> list above.=20
3 <font color=3D"#9900CC">  (C)</font> =3D Game Boy Color mode. Read only -=
 should stay at 0.=20
4 <font color=3D"#0099FF">  (A)</font> =3D This bit controls the starting a=
ddress of the bitmap in bitmapped modes
          and is used for page flipping. See the description of the specifi=
c
          <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#Video%20Modes">video mode</a> for details.=20
5   <font color=3D"#008800">(B)</font> =3D Force processing during hblank. =
Setting this causes the display
          controller to process data earlier and longer, beginning from the=
 end of
          the previous scanline up to the end of the current one. This adde=
d
          processing time can help prevent flickering when there are too ma=
ny
          sprites on a scanline.
6   <font color=3D"#FF3300">(D)</font> =3D Sets whether <a href=3D"http://w=
ww.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#OAM%20(sprites)">sprites</a>=
 stored in VRAM use 1 dimension or 2.
          1 - 1d: tiles are are stored sequentially=20
          0 - 2d: each row of tiles is stored 32 x 64 bytes in from the sta=
rt of the
          previous row.</pre>
<pre>7   (<font color=3D"#FF0099">F)</font> =3D Force the display to go bla=
nk when set. This can be used to save power=20
          when the display isn't needed, or to blank the screen when it is =
being
          built up (such as in mode 3, which has only one framebuffer). On =
the SNES,
          transfers rates to VRAM were improved during a forced blank; it i=
s logical
          to assume that this would also hold true on the GBA.

8 <font color=3D"#9900CC">  (I)</font> =3D If set, enable display of BG0.=
=20
9   <font color=3D"#0099FF">(J)</font> =3D If set, enable display of BG1.=
=20
A <font color=3D"#008800">  (K)</font> =3D If set, enable display of BG2.=
=20
B   (<font color=3D"#FF3300">L)</font> =3D If set, enable display of BG3.=
=20
C <font color=3D"#FF0099">  (S)</font> =3D If set, enable display of <a hre=
f=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#OAM%20(sprites)=
">OAM (sprites)</a>.=20
D <font color=3D"#9900CC">  (U</font>) =3D Enable Window 0
E <font color=3D"#0099FF">  (V)</font> =3D Enable Window 1=20
F <font color=3D"#008800">  (W)</font> =3D Enable Sprite Windows </pre>
<p><br>
<br>
<b>Address: 0x4000004 - <a name=3D"REG_STAT"></a>REG_DISPSTAT</b></p>
<pre>                <font color=3D"#FF0000">      </font>       <font colo=
r=3D"#FF0000">R R R</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#9900CC">T T T T  T T T T</font> <font color=3D"#BBBBBB"> X =
X</font><font color=3D"#663300"> </font><font color=3D"#FF0099">Y</font> <f=
ont color=3D"#FF3300">H</font>  <font color=3D"#008800">V</font> <font colo=
r=3D"#0099FF">Z</font> <font color=3D"#9900CC">G</font> <font color=3D"#FF0=
099">W</font> </pre>
<pre>0   <font color=3D"#FF0099">(W)</font> =3D V Refresh status. This will=
 be 0 during VDraw, and 1 during VBlank.=20
          VDraw lasts for 160 scanlines; VBlank follows after that and last=
s 68
          scanlines. Checking this is one alternative to checking <a href=
=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_VCOUNT">REG_=
VCOUNT</a>.=20

1 <font color=3D"#9900CC">  (G)</font> =3D H Refresh status. This will be 0=
 during HDraw, and 1 during HBlank HDraw
          lasts for approximately 1004 cycles; HBlank follows, and lasts
          approximately 228 cycles, though the time and length of HBlank ma=
y in
          fact vary based on the number of sprites and on rotation/scaling/=
blending
          effects being performed on the current line.=20

2 <font color=3D"#0099FF">  (Z)</font> =3D VCount Triggered Status. Gets se=
t to 1 when a Y trigger interrupt occurs.=20
3 <font color=3D"#008800">  (V)</font> =3D Enables LCD's VBlank <a href=3D"=
http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Hardware%20Interrupt=
s">IRQ</a>. This interrupt goes off at the start of VBlank.=20
4 <font color=3D"#FF3300">  (H)</font> =3D Enables LCD's HBlank <a href=3D"=
http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Hardware%20Interrupt=
s">IRQ</a>. This interrupt goes off at the start of HBlank.=20
5 <font color=3D"#FF0099">  (Y)</font> =3D Enable VCount trigger <a href=3D=
"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Hardware%20Interrup=
ts">IRQ</a>. Goes off when VCount line trigger is reached.=20
8-F <font color=3D"#9900CC">(T)</font> =3D Vcount line trigger. Set this to=
 the VCount value you wish to trigger an
          interrupt. </pre>
<p><br>
<br>
<b>Address: 0x4000006 - LCY / <a name=3D"REG_VCOUNT"></a>REG_VCOUNT (Read O=
nly)</b><br>
<br>
This location stores the current y location of the LCD hardware. It is incr=
emented as the lines are drawn. The
160 lines of display are followed by 68 lines of Vblank period, before the =
whole thing starts again for the next
frame. Waiting for this register to reach 160 is one way to synchronize a p=
rogram to 60Hz.
</p><h3>
<hr align=3D"CENTER">
<b><br>
Addresses: 0x400008 - 0x400001E - <a name=3D"Background Registers"></a>Back=
ground Registers</b></h3>
<p><br>
<b>Address: 0x4000008 - <a name=3D"REG_BG0"></a>REG_BG0CNT <br>
Address: 0x400000A - <a name=3D"REG_BG1"></a>REG_BG1CNT <br>
Address: 0x400000C - <a name=3D"REG_BG2"></a>REG_BG2CNT <br>
Address: 0x400000E - <a name=3D"REG_BG3"></a>REG_BG3CNT </b><br>
<br>
These addresses set up the four background layers. The format is:</p>
<pre>    <font color=3D"#DD0000">?</font>              =20
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#9900CC">Z Z</font> <font color=3D"#FF0099">V</font> <font c=
olor=3D"#FF3300">M  M M M M</font> <font color=3D"#008800"> A</font> <font =
color=3D"#0099FF">C</font> <font color=3D"#BBBBBB">X X  </font><font color=
=3D"#9900CC">S S</font> <font color=3D"#FF0099">P P</font>=20

0-1 <font color=3D"#FF0099">(P)</font> =3D <a name=3D"Priority"></a>Priorit=
y - 00 highest, 11 lowest
          Priorities are ordered as follows:

          "Front"
          1. Sprite with priority 0
          2. BG with     priority 0

          3. Sprite with priority 1
          4. BG with     priority 1

          5. Sprite with priority 2
          6. BG with     priority 2

          7. Sprite with priority 3
          8. BG with     priority 3

          9. Backdrop
          "Back"

          When multiple backgrounds have the same priority, the order
          from front to back is:  BG0, BG1, BG2, BG3.  Sprites of the same
          priority are ordered similarly, with the first sprite in OAM
          appearing in front.         =20

2-3 <font color=3D"#9900CC">(S)</font> =3D Starting address of character ti=
le data
          Address =3D 0x6000000 + S * 0x4000
6 <font color=3D"#0099FF">  (C)</font> =3D Mosiac effect - 1 on, 0 off

7 <font color=3D"#008800">  (A)</font> =3D <a href=3D"http://www.cs.rit.edu=
/~tjh8300/CowBite/CowBiteSpec.htm#Palette">Color palette</a> type -
          1 - standard 256 color pallete
          0 - each tile uses one of 16 different 16 color palettes (no effe=
ct on
              rotates/scale backgrounds, which are always 256 color)

8-C <font color=3D"#FF3300">(M)</font> =3D Starting address of character ti=
le map
          Address =3D 0x6000000 + M * 0x800
D   <font color=3D"#FF0099">(V)</font> =3D Screen Over. Used to determine w=
hether <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Sc=
ale/Rotate%20Backgrounds">rotational backgrounds</a> get tiled
          repeatedly at the edges or are displayed as a single "tile" with =
the area
          outside transparent. This is forced to 0 (read only) for backgrou=
nds=20
          0 and 1 (only).

E-F <font color=3D"#9900CC">(Z)</font> =3D Size of tile map
          For <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec=
.htm#Text%20Backgrounds">"text" backgrounds</a>:=20
          00 : 256x256 (32x32 tiles)=20
          01 : 512x256 (64x32 tiles)=20
          10 : 256x512 (32x64 tiles)=20
          11 : 512x512 (64x64 tiles)=20

          For <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec=
.htm#Scale/Rotate%20Backgrounds">rotational backgrounds</a>:=20
          00 : 128x128 (16x16 tiles)=20
          01 : 256x256 (32x32 tiles)=20
          10 : 512x512 (64x64 tiles)
          11 : 1024x1024 (128x128 tiles)</pre>
<p><br>
<b>Address: 0x4000010 - <a name=3D"REG_BG0SCX"></a>REG_BG0HOFS Horizontal s=
croll co-ordinate for BG0 (Write Only)<br>
Address: 0x4000012 - <a name=3D"REG_BG0SCY"></a>REG_BG0VOFS Vertical scroll=
 co-ordinate for BG0 (Write Only)<br>
Address: 0x4000014 - REG_BG1HOFS Horizontal scroll co-ordinate for BG1 (Wri=
te Only)<br>
Address: 0x4000016 - REG_BG1VOFS Vertical scroll co-ordinate for BG1 (Write=
 Only)<br>
Address: 0x4000018 - REG_BG2HOFS Horizontal scroll co-ordinate for BG2 (Wri=
te Only)<br>
Address: 0x400001A - REG_BG2VOFS Vertical scroll co-ordinate for BG2 (Write=
 Only)<br>
Address: 0x400001C - REG_BG3HOFS Horizontal scroll co-ordinate for BG3 (Wri=
te Only)<br>
Address: 0x400001E - REG_BG3VOFS Vertical scroll co-ordinate for BG3 (Write=
 Only)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X </font><font color=3D"#FF0099">S S  S =
S S S  S S S S</font> </pre>
<pre>0-9<font color=3D"#FF0099"> (S)</font> =3D Scroll value (pixels) </pre=
>
<p><br>
These registers are only effective for <a href=3D"http://www.cs.rit.edu/~tj=
h8300/CowBite/CowBiteSpec.htm#Text%20Backgrounds">text
backgrounds</a>; they set the pixel that is displayed in the top left hand =
corner of the GBA's display. In other
words, a value of -5, -5 puts the upper left hand corner of your background=
 at x=3D5,y=3D5. All four BG planes wrap
when they reach their right or bottom edges.
</p><h3><br>

<hr align=3D"CENTER">
<b><br>
Addresses: 0x4000020 - 0x4000026 / 0x4000030 - 0x4000036 - <a name=3D"Backg=
round Rotation/Scaling Regi"></a>Background
Rotation/Scaling Registers (Write Only)</b></h3>
<p>These registers affect the translation, rotation, and scaling of tile-ba=
sed <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Scale=
/Rotate%20Backgrounds">rotate/scale
backgrounds</a> as well as the <a href=3D"http://www.cs.rit.edu/~tjh8300/Co=
wBite/CowBiteSpec.htm#Bitmapped%20Backgrounds">bitmapped
backgrounds</a> (which should be treated as BG2 for this purpose). The func=
tion of these registers is very hard
to describe in words but easy to see the effects of on screen. I highly rec=
ommend checking out Stephen Stair's
RSDemo - it lets you see the contents of the regs as you modify them as wel=
l as the effect they have on the background.
Should also be somewhat useful for figuring out sprite rotation and scaling=
.</p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#0099FF">S</font> <font color=3D"#9900CC">I I I  I I I I</fo=
nt> <font color=3D"#FF0099"> F F F F  F F F F</font> </pre>
<pre>0-7 <font color=3D"#FF0099">(F)</font> =3D Fraction=20
8-E <font color=3D"#9900CC">(I)</font> =3D Integer=20
F   <font color=3D"#0099FF">(S)</font> =3D Sign bit=20
</pre>
<p>These registers apply only to <a href=3D"http://www.cs.rit.edu/~tjh8300/=
CowBite/CowBiteSpec.htm#Scale/Rotate%20Backgrounds">Rotate/Scale
backgrounds</a>. Individual descriptions follow: <br>
<br>
<b>Address: 0x4000020 - <a name=3D"REG_BG2DX/PA"></a>REG_BG2PA (BG2 Read So=
urce Pixel X Increment)(Write Only) <br>
Address: 0x4000030 - <a name=3D"REG_BG3DX/PA"></a>REG_BG3PA (BG3 Read Sourc=
e Pixel X Increment) (Write Only)</b><br>
<br>
The effect of these registers is to scale the background (relative to the u=
pper left corner) in the x direction
by an amount equal to 1/(register value). <br>
<br>
<b>Address: 0x4000022 - <a name=3D"REG_BG2DMX/PB"></a>REG_BG2PB (BG2 Write =
Destination Pixel X Increment) (Write
Only)<br>
Address: 0x4000032 - <a name=3D"REG_BG3DMX/PB"></a>REG_BG3PB (BG3 Write Des=
tination Pixel X Increment) (Write Only)</b><br>
<br>
The effect of these registers is to shear the x coordinates of the backgrou=
nd over y, relative to the upper left
corner. A value of 0 will result in no shearing, a value of 1.00 will make =
the background appear to be sheared
left as you go down the screen, and a value of -1 will make the background =
appear sheared right as you go down
the screen. <br>
<br>
<b>Address: 0x4000024 - <a name=3D"REG_BG2DY/PC"></a>REG_BG2PC (BG2 Read So=
urce Pixel Y Increment) (Write Only)<br>
Address: 0x4000034 - <a name=3D"REG_BG3DY/PC"></a>REG_BG3PC</b> <b>(BG3 Rea=
d Source Pixel Y Increment) (Write Only)</b><br>
<br>
The effect of these registers is to shear the y coordinates of the backgrou=
nd over x, relative to the upper left
corner. A value of 0 will result in no shearing, a value of 1.00 will make =
the background appear to be sheared
upwards to the right, and a value of -1 will make the background appear she=
ared downwards and to the right. <br>
<br>
<b>Address: 0x4000026 - REG_<a name=3D"REG_BG2DMY/PD"></a>BG2PD (BG2 Write =
Destination Pixel Y Increment) (Write
Only)<br>
Address: 0x4000036 - REG_<a name=3D"REG_BG3DMY/PD"></a>BG3PD (BG3 Write Des=
tination Pixel Y Increment) (Write Only)</b><br>
<br>
The effect of these registers is to scale the background in the y direction=
 (relative to the upper left corner)
by an amount equal to 1/(register value). <br>
<br>

</p><hr align=3D"CENTER">
<br>
<b>Address: 0x4000028 - <a name=3D"REG_BG2X"></a>REG_BG2X (X Coordinate for=
 BG2 Rotational Background)(Write Only)<br>
Address: 0x4000038 - <a name=3D"REG_BG3X"></a>REG_BG3X (X Coordinate for BG=
3 Rotational Background)(Write Only)<br>
<br>
Address: 0x400002C - <a name=3D"REG_BG2Y"></a>REG_BG2Y (Y Coordinate for BG=
2 Rotational Background)(Write Only)<br>
Address: 0x400003C - <a name=3D"REG_BG3Y"></a>REG_BG3Y (Y Coordinate for BG=
3 Rotational Background)(Write Only)</b><p></p>
<p>
</p><pre>31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  1=
1 10 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X  X  X  X </font> <font color=3D"#0099FF"> S</font=
>  <font color=3D"#9900CC">I  I  I   I  I  I  I   I  I  I  I   I  I  I  I  =
 I  I  I I</font> <font color=3D"#9900CC"> </font><font color=3D"#FF0099">F=
 F F F  F F F F</font> </pre>
<pre>0-7 <font color=3D"#FF0099"> (F)</font> - Fraction=20
8-26 <font color=3D"#9900CC">(I)</font> - Integer=20
27 <font color=3D"#0099FF">  (S)</font> - Sign bit </pre>
<p><br>
These registers define the location of the pixel that appears at 0,0. They =
are very similar to the background scrolling
registers, <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.ht=
m#REG_BG0SCX">REG_HOFS</a> and <a href=3D"http://www.cs.rit.edu/~tjh8300/Co=
wBite/CowBiteSpec.htm#REG_BG0SCY">REG_VOFS</a>,
which become disabled when a <a href=3D"http://www.cs.rit.edu/~tjh8300/CowB=
ite/CowBiteSpec.htm#Scale/Rotate%20Backgrounds">rotate/
scale background</a> is in use. <br>
<br>
<br>

</p><hr align=3D"CENTER">

<h3><b>Addresses: 0x4000040 - 0x400004A - <a name=3D"Windowing Registers"><=
/a>Windowing Registers</b></h3>
<p><br>
<b>Address: 0x4000040 - <a name=3D"REG_WIN0_H"></a>REG_WIN0H (</b><a href=
=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Windowing"><b>Wi=
ndow</b></a><b>
0 X Coordinates) (Write Only)<br>
Address: 0x4000042 - <a name=3D"REG_WIN1_H"></a>REG_WIN1H (</b><a href=3D"h=
ttp://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Windowing"><b>Window<=
/b></a><b>
1 X Coordinates)(Write Only)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#9900CC">L L L L  L L L L</font> <font color=3D"#FF0099"> R =
R R R  R R R R</font> </pre>
<pre>0-7 <font color=3D"#FF0099">(R)</font> =3D X coordinate for the rightm=
ost side of the window=20
8-F <font color=3D"#9900CC">(L)</font> =3D X coordinate for the leftmost si=
de of the window </pre>
<p><br>
<b>Address: 0x4000044 - <a name=3D"REG_WIN0_V"></a>REG_WIN0V (</b><a href=
=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Windowing"><b>Wi=
ndow</b></a><b>
0 Y Coordinates) (Write Only)<br>
Address: 0x4000046 - <a name=3D"REG_WIN1_V"></a>REG_WIN1V (</b><a href=3D"h=
ttp://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Windowing"><b>Window<=
/b></a><b>
1 Y Coordinates)(Write Only)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#9900CC">T T T T  T T T T</font>  <font color=3D"#FF0099">B =
B B B  B B B B</font> </pre>
<pre>0-7 <font color=3D"#FF0099">(B)</font> =3D Y coordinate for the bottom=
 of the window=20
8-F <font color=3D"#9900CC">(T)</font> =3D Y coordinate for the top of the =
window </pre>
<p><br>
<b>Address: 0x4000048 - <a name=3D"REG_WIN_IN"></a>REG_WININ (Inside </b><a=
 href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Windowing">=
<b>Window</b></a><b>
Settings)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X</font> <font color=3D"#9900CC">T</font> <font c=
olor=3D"#FF0099">S</font> <font color=3D"#FF3300"> R</font> <font color=3D"=
#008800">Q</font> <font color=3D"#0099FF">P</font> <font color=3D"#9900CC">=
O</font> <font color=3D"#BBBBBB"> X X</font> <font color=3D"#FF0099">L</fon=
t> <font color=3D"#FF3300">K</font>  <font color=3D"#008800">J</font> <font=
 color=3D"#0099FF">I</font> <font color=3D"#9900CC">H</font> <font color=3D=
"#FF0099">G</font> </pre>
<pre>0 <font color=3D"#FF0099">(G)</font> =3D BG0 in win0=20
1 <font color=3D"#9900CC">(H)</font> =3D BG1 in win0=20
2 <font color=3D"#0099FF">(I)</font> =3D BG2 in win0=20
3 <font color=3D"#008800">(J)</font> =3D BG3 in win0=20
4 <font color=3D"#FF3300">(K)</font> =3D Sprites in win0=20
5 <font color=3D"#FF0099">(L)</font> =3D Blends in win0=20
8 <font color=3D"#9900CC">(O)</font> =3D BG0 in win1=20
9 <font color=3D"#0099FF">(P)</font> =3D BG1 in win1=20
A <font color=3D"#008800">(Q)</font> =3D BG2 in win1=20
B <font color=3D"#FF3300">(R)</font> =3D BG3 in win1=20
C <font color=3D"#FF0099">(S)</font> =3D Sprites in win1=20
D <font color=3D"#9900CC">(T)</font> =3D Blends in win1 </pre>
<p><br>
<br>
<b>Address: 0x400004A - <a name=3D"REG_WIN_OUT"></a>REG_WINOUT (Outside </b=
><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Windowin=
g"><b>Window</b></a><b>
and Sprite </b><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpe=
c.htm#Windowing"><b>Window</b></a><b>)</b></p>
<pre><font color=3D"#FF0000">
</font>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X </font><font color=3D"#9900CC">T</font> <font c=
olor=3D"#FF0099">S</font> <font color=3D"#FF3300"> R</font> <font color=3D"=
#008800">Q</font> <font color=3D"#0099FF">P</font> <font color=3D"#9900CC">=
O</font> <font color=3D"#BBBBBB"> X X </font><font color=3D"#FF0099">L</fon=
t> <font color=3D"#FF3300">K</font> <font color=3D"#008800"> J</font> <font=
 color=3D"#0099FF">I</font> <font color=3D"#9900CC">H</font> <font color=3D=
"#FF0099">G</font> </pre>
<pre>0 <font color=3D"#FF0099">(G)</font> =3D BG0 outside
1 <font color=3D"#9900CC">(H)</font> =3D BG1 outside=20
2 <font color=3D"#0099FF">(I)</font> =3D BG2 outside=20
3 <font color=3D"#008800">(J)</font> =3D BG3 outside=20
4 <font color=3D"#FF3300">(K)</font> =3D Sprites outside=20
5 <font color=3D"#FF0099">(L)</font> =3D Blends outside
8 <font color=3D"#9900CC">(O)</font> =3D BG0 in sprite win=20
9 <font color=3D"#0099FF">(P)</font> =3D BG1 in sprite win=20
A <font color=3D"#008800">(Q)</font> =3D BG2 in sprite win=20
B <font color=3D"#FF3300">(R)</font> =3D BG3 in sprite win=20
C <font color=3D"#FF0099">(S)</font> =3D Sprites in sprite win=20
D <font color=3D"#9900CC">(T)</font> =3D Blends in sprite win </pre>
<p><br>

</p><hr align=3D"CENTER">

<h3><b>Addresses: 0x400004C - 0x4000054 - <a name=3D"Effects Registers"></a=
>Effects Registers</b></h3>
<p><br>
<b>Address: 0x400004C - <a name=3D"REG_MOSAIC"></a>REG_MOSAIC (Write Only)<=
/b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#008800">V V V V</font> <font color=3D"#0099FF"> U U U U</fo=
nt>  <font color=3D"#9900CC">J J J J</font> <font color=3D"#FF0099"> I I I =
I</font> </pre>
<pre>0-3 <font color=3D"#FF0099">(I)</font> =3D BG X Size=20
4-7 <font color=3D"#9900CC">(J)</font> =3D BG Y Size=20
8-B <font color=3D"#0099FF">(U)</font> =3D Sprite X Size=20
C-F <font color=3D"#008800">(V)</font> =3D Sprite Y Size </pre>
<p><br>
Use this register to control the size of the mosaic on backgrounds/sprites =
that have mosaic enabled.. <br>
<br>
<br>
<b>Address: 0x4000050 - <a name=3D"REG_BLDCNT"></a>REG_BLDMOD</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X</font> <font color=3D"#0099FF">T</font> <font c=
olor=3D"#9900CC">S</font> <font color=3D"#FF0099"> R</font> <font color=3D"=
#FF3300">Q</font> <font color=3D"#008800">P</font> <font color=3D"#0099FF">=
O</font> <font color=3D"#9900CC"> M M</font> <font color=3D"#FF0099">L</fon=
t> <font color=3D"#FF3300">K</font>  <font color=3D"#008800">J</font> <font=
 color=3D"#0099FF">I</font> <font color=3D"#9900CC">H</font> <font color=3D=
"#FF0099">G</font> </pre>
<pre>0 <font color=3D"#FF0099">  (G)</font> =3D Blend BG0 (source)=20
1 <font color=3D"#9900CC">  (H)</font> =3D Blend Bg1 (source)=20
2<font color=3D"#0099FF">   (I)</font> =3D Blend BG2 (source)=20
3<font color=3D"#008800">   (J)</font> =3D Blend BG3 (source)=20
4 <font color=3D"#FF3300">  (K)</font> =3D Blend sprites (source)=20
5   <font color=3D"#FF0099">(L)</font> =3D Blend backdrop (source)=20
6-7 <font color=3D"#9900CC">(M)</font> =3D Blend Mode
         =20
          There are four different modes:=20
          00: All effects off=20
          01: alpha blend=20
          10: lighten (fade to white)=20
          11: darken (fade to black)</pre>
<pre>8 <font color=3D"#0099FF">  (O)</font> =3D Blend BG0 (target)=20
9 <font color=3D"#008800">  (P)</font> =3D Blend BG1 (target)=20
A <font color=3D"#FF3300">  (Q)</font> =3D Blend BG2 (target)=20
B <font color=3D"#FF0099">  (R)</font> =3D Blend BG3 (target)=20
C <font color=3D"#9900CC">  (S)</font> =3D Blend sprites (target)
D <font color=3D"#0099FF">  (T)</font> =3D Blend backdrop (target)</pre>
<p><br>
Use this register to determine the blending mode and which layer(s) you wis=
h to perform blending on. In the case
of alpha blends (Mode 01), specify the layers that are "on top" using the s=
ource flags (bits 0 - 5) and
the layers that are on the bottom using the target flags (bits 8-13). The t=
arget layer must be below the source
layer in terms of its <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Cow=
BiteSpec.htm#Priority">priority</a>, or
the blend will not take effect. Other things to note about alpha blends:


</p><blockquote>
	<p>- If there is more than one target layer, the blend will only occur for=
 a target with lower priority in areas
	where it shows through targets of higher priority due to the transparent p=
ixel being set<br>
	- Source layers will only blend with areas of a target layer that are visi=
ble beneath them. If another layer is
	blocking the way (even if it is another source layer), there will be no bl=
end and the original source color will
	be drawn.<br>
	- As a result of these two conditions, it is never possible for any given =
pixel to be a blend of more than 2 layers.
	This eliminates the possiblity of using these registers to have 3 or more =
layers of translucent graphics showing
	through one another.<br>
	- A layer cannot blend with itself<br>
	<br>
	- If an obj has semi-transparency enabled, it will blend normally (as if i=
t were specified as a source layer)<br>
	- Unfortunately, it is not possible to alpha blend sprites against one ano=
ther, no matter how your prioritize them.
	Alpha blended sprites that are "in front of" other sprites will blend with=
 the other target layers while
	still occluding the sprites behind them (i.e. it will look like the portio=
n of the non-blended sprite that is behind
	the blended one has disappeared), for a most unnatural effect.</p>

</blockquote>

<p><br>
<br>
<b>Address: 0x4000052 - <a name=3D"REG_BLDALPHA"></a>REG_COLEV (Write Only)=
</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X </font><font color=3D"#9900CC">B  B B B B</fo=
nt><font color=3D"#BBBBBB">  X X X </font><font color=3D"#FF0099">A  A A A =
A</font> </pre>
<pre>0-4 <font color=3D"#FF0099">(A)</font> =3D Coefficient A, the source p=
ixel (layer above)
8-C <font color=3D"#9900CC">(B)</font> =3D Coefficient B, the target pixel =
(layer below)</pre>
<p><br>
Use this in conjunction with <a href=3D"http://www.cs.rit.edu/~tjh8300/CowB=
ite/CowBiteSpec.htm#REG_BLDCNT">REG_BLDCNT</a>
to determine the amount of blending between layers. An unblended pixel of n=
ormal intensity is is considered to
have a coefficient of 16. Coefficient A and Coefficient B determine the rat=
io of each of the sources that will
get mixed into the final image. Thus, if A is 12 and B is 4, the resulting =
image will appear to be 12/16 the color
of A and 4/16 the color of B. Note that A and B can add up to be greater th=
an 16 (for an additive or brightening
effect) or less than 16 (for a darkening effect).<br>
<br>
<b>Address: 0x4000054 - <a name=3D"REG_BLDY"></a>REG_COLEY (Write Only)</b>=
</p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X X  X X X </font><font color=3D"#FF00=
99">F  F F F F</font> </pre>
<pre>0-4 <font color=3D"#FF0099">(F)</font> =3D The lighten/darken value </=
pre>
<p><br>
This is the amount by which to lighten or darken the source layers (as spec=
ified in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#=
REG_BLDCNT">REG_BLDCNT</a>)
.<br>
The higher the value, the greater the fade. 16 is the peak fade value; valu=
es from 16 - 31 shade the layer with
either pure black (for a darken) or pure white (for a lighten).
</p><h3><br>

<hr align=3D"CENTER">
<br>
Addresses 0x040000060 - 0x0400000A6 (<a name=3D"Sound Controls"></a>Sound C=
ontrols: Partially unimplemented in CowBite)</h3>
<p>Note: I've obtained this info (most of it verbatim) from Uze's <a href=
=3D"http://belogic.com/gba/">BeLogic</a>
unofficial GBA sound info site, which gives a much more thorough explanatio=
n as well as some sample source code
and demos. Thanks to Uze for providing such a great resource on GBA sound.<=
br>
<b><br>
Address: 0x04000060 - <a name=3D"REG_SOUND1CNT_L"></a>REG_SOUND1CNT_L (Soun=
d 1 Sweep control) (Unimplemented in CowBite)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X X  X </font><font color=3D"#0099FF">=
T T T</font> <font color=3D"#9900CC"> A</font> <font color=3D"#FF0099">S S<=
b> </b>S</font>

0-2 <font color=3D"#FF0099">(S)</font> =3D Number of sweep shifts. These co=
ntrol the amount of change in=20
          frequency (either increase or decrease) at each change. The wave'=
s new
          period is given by: T=3DT=B1T/(2<sup>n</sup>), where <i>n</i> is =
the sweep shift's value.

3 <font color=3D"#9900CC">  (A)</font> =3D Sweep increase or decrease. When=
 decrementing, if the frequency value
          gets smaller than zero, the previous value is retained. When
          incrementing, if the frequency gets greater than the maximum freq=
uency
          (131Khz or 2048 for the register value) the sound stops.
          0 - Addition (frequency increase)
          1 - Subtraction (frequency decrease)</pre>
<pre>4-6 <font color=3D"#0099FF">(T)</font> =3D Sweep Time. This is the del=
ay between sweep shifts. After each delay,
          the frequency increments or decrements.
          000:  Disable sweep function
          001:  Ts=3D1 / 128khz (7.8 ms)
          010:  Ts=3D2 / 128khz (15.6 ms)
          011:  Ts=3D3 / 128 khz (23.4 ms)
          100:  Ts=3D4 / 128 khz (31.3 ms)
          101:  Ts=3D5 / 128 khz (39.1 ms)
          110:  Ts=3D6 / 128 khz (46.9 ms)
          111:  Ts=3D7 / 128 khz (54.7 ms)</pre>
<p><br>
Sound channel 1 produces a square wave with envelope and frequency sweep fu=
nctions. This register controls the
frequency sweep function. When the sweep function is not required, set the =
sweep time to zero and set the increase/decrease
bit to 1. <br>
<br>
<b><br>
Address: 0x04000062 - <a name=3D"REG_SOUND1CNT_H"></a>REG_SOUND1CNT_H (Soun=
d 1 Length, wave duty and envelope control)(Unimplemented
in CowBite)</b></p>
<pre>                    <font color=3D"#CC9900">  W W  W W W W</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#FF3300">I I I I</font> <font color=3D"#008800"> M</font> <f=
ont color=3D"#0099FF">T T T</font>  <font color=3D"#9900CC">D D</font> <fon=
t color=3D"#FF0099">L L  L L L L</font></pre>
<pre>0-5 <font color=3D"#FF0099">(L)</font> =3D Sound length. This is a 6 b=
it value obtained from the following
          formula: Sound length=3D (64-register value)*(1/256) seconds. Aft=
er the
          sound length has been changed, the sound channel must be resetted=
 via
          bit F of <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBit=
eSpec.htm#REG_SOUND1CNT_X">REG_SOUND1CNT_X</a> (when using timed mode).=20

6-7 <font color=3D"#9900CC">(D)</font> =3D Wave duty cycle. This controls t=
he percentage of the ON state of the
          square wave.

          00 - 12.5%
          01 - 25%
          10 - 50%
          11 - 75%</pre>
<pre>8-A <font color=3D"#0099FF">(T)</font> =3D Envelope step time. This is=
 the delay between successive envelope
          increase or decrease. It is given by the following formula:=20
          Time=3Dregister value*(1/64) seconds.=20

B <font color=3D"#008800">  (M)</font> =3D Envelope mode. Controls if the e=
nvelope is to increase or decrease in
          volume over time.
       =20
          0 - Envelope decreases
          1 - Envelope increases</pre>
<pre>C-F <font color=3D"#FF3300">(I)</font> =3D Initial Envelope value<b>. =
</b>1111 produces the maximum volume and 0000 mutes
          the sound. When sound 1 is playing, modifying the volume envelope=
 bits
          has no effect until the sound is resetted.</pre>
<p><b><br>
<br>
Address: 0x04000064 - <a name=3D"REG_SOUND1CNT_X"></a>REG_SOUND1CNT_X (Soun=
d 1 Frequency, reset and loop control)(Unimplemented
in CowBite)</b></p>
<pre><font color=3D"#CC9900">W</font>         <font color=3D"#CC9900"> W W =
W  W W W W  W W W W</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#0099FF">R</font> <font color=3D"#9900CC">T</font> <font col=
or=3D"#BBBBBB">X X  X</font> <font color=3D"#FF0099">F F F  F F F F  F F F =
F</font>

</pre>
<pre>0-A <font color=3D"#FF0099">(F)</font> =3D Sound frequency. The minimu=
m frequency is 64Hz and the maximum is
          131Khz. Can be calculated from the following formula:
          F(hz)=3D4194304/(32*(2048-register value)).

E   <font color=3D"#9900CC">(T)</font> =3D Timed sound. When set to 0, soun=
d 1 is played continuously regardless
          of the length data in <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#REG_SOUND1CNT_H">REG_SOUND1CNT_H</a>. When set to 1,=
 sound is played
          for that specified length and after that, bit 0 of <a href=3D"htt=
p://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SOUNDCNT_X">REG_SOU=
NDCNT_X</a> is
          reset.
F<font color=3D"#0099FF">   (R)</font> =3D Sound reset. When set, sound res=
ets and restarts at the specified
          frequency. When sound 1 is playing, modifying the volume envelope=
 bits
          has no effect until the sound is resetted. Frequency and sound re=
set must
          be perfomed in a single write since both are write only. Frequenc=
y can
          always be changed without resetting the sound channel. </pre>
<p><br>
<b><br>
Address: 0x04000068 - <a name=3D"REG_SOUND2CNT_L"></a>REG_SOUND2CNT_L (Soun=
d 2 Length, wave duty and envelope control)(Unimplemented
in CowBite)</b></p>
<pre>                     <font color=3D"#CC9900"> W W  W W W W</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#FF3300">I I I I</font> <font color=3D"#008800"> M</font> <f=
ont color=3D"#0099FF">T T T</font> <font color=3D"#9900CC"> D D</font> <fon=
t color=3D"#FF0099">L L  L L L L</font></pre>
<pre>0-5 <font color=3D"#FF0099">(L)</font> =3D Sound length. This is a 6 b=
it value obtained from the following
          formula:  Sound length=3D (64-register value)*(1/256) seconds.
          After the sound length has been changed, the sound channel must b=
e
          resetted via bit F of <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#REG_SOUND2CNT_H">REG_SOUND1CNT_X</a> (when using tim=
ed mode).=20

6-7 <font color=3D"#9900CC">(D)</font> =3D Wave duty cycle. This controls t=
he percentage of the ON state of
          the square wave.
         =20
          00 - 12.5%
          01 - 25%
          10 - 50%
          11 - 75%</pre>
<pre>8-A <font color=3D"#0099FF">(T)</font> =3D Envelope step time. This is=
 the delay between successive envelope increase
          or decrease. It is given by the following formula: Time=3Dregiste=
r value*(1/64)
          seconds.=20

B   <font color=3D"#008800">(M)</font> =3D Envelope mode. Controls if the e=
nvelope is to increase or decrease in volume
          over time.
       =20
          0 - Envelope decreases
          1 - Envelope increases</pre>
<pre>C-F <font color=3D"#FF3300">(I)</font> =3D Initial Envelope value<b>. =
</b>1111 produces the maximum volume and 0000 mutes
          the sound. When sound 2 is playing, modifying the volume envelope=
 bits has
          no effect until the sound is resetted.<b>
</b></pre>
<p><b><br>
Address: 0x0400006C- <a name=3D"REG_SOUND2CNT_H"></a>REG_SOUND2CNT_H (Sound=
 2 Frequency, reset and loop control)(Unimplemented
in CowBite)</b></p>
<pre><font color=3D"#CC9900">W</font>       <font color=3D"#CC9900">   W W =
W  W W W W  W W W W</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#0099FF">R</font> <font color=3D"#9900CC">T</font><font colo=
r=3D"#BBBBBB"> X X  X </font><font color=3D"#FF0099">F F F  F F F F  F F F =
F</font></pre>
<pre>0-A <font color=3D"#FF0099">(F)</font> =3D Sound frequency. The minimu=
m frequency is 64Hz and the maximum is
         131Khz. Can be calculated from the following formula:
         F(hz)=3D4194304/(32*(2048-register value)).

E   <font color=3D"#9900CC">(T)</font> =3D Timed sound. When set to 0, soun=
d 2 is played continuously regardless of
          the length data in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowB=
ite/CowBiteSpec.htm#REG_SOUND2CNT_L">REG_SOUND2CNT_L</a>. When set to 1, so=
und is played for
          that specified length and after that, bit 1 of <a href=3D"http://=
www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SOUNDCNT_X">REG_SOUNDCN=
T_X</a> is reset.

F <font color=3D"#0099FF">  (R)</font> =3D Sound reset. When set, sound res=
ets and restarts at the specified
          frequency. When sound 2 is playing, modifying the volume envelope=
 bits
          has no effect until the sound is resetted. Frequency and sound re=
set must
          be perfomed in a single write since both are write only. Frequenc=
y can
          always be changed without resetting the sound channel.</pre>
<p><b><br>
<br>
Address: 0x04000070 - <a name=3D"REG_SOUND3CNT_L"></a>REG_SOUND3CNT_L (Soun=
d 3 Enable and wave ram bank control)(Unimplemented
in CowBite)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X X</font> <font color=3D"#0099FF"> N<=
/font> <font color=3D"#9900CC">S</font> <font color=3D"#FF0099">M</font> <f=
ont color=3D"#BBBBBB">X  X X X X</font>

</pre>
<pre>5 <font color=3D"#FF0099">(M)</font> =3D Bank Mode (0 - 2 32 sample ba=
nks, 1 - 1 64 sample bank)<b>
</b>6 <font color=3D"#9900CC">(S)</font> =3D Bank Select<b>. </b>Controls w=
hich bank is active for playing/reloading. If set
        to 0, samples are played from bank 0 and writing to the Wave Ram wi=
ll
        store the data in Bank 1, and vice-versa.
7 <font color=3D"#0099FF">(N)</font> =3D Sound Channel 3 output enable. Whe=
n this is set and bit 15 from
        <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#R=
EG_SOUND3CNT_X">REG_SOUND3CNT_X</a> is set, the sound starts to play.
</pre>
<p>Sound channel 3 is a circuit that can produce an arbitrary wave pattern.=
 Samples are 4 bit, 8 samples per word,
and are located in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBit=
eSpec.htm#REG_WAVE_RAM0_L">Wave Ram registers</a>
from 0x400090 to 0x40009F. The Wave Ram is banked, providing the ability to=
 play a 64 samples pattern or to select
between two 32 samples patterns (Bit 5). Sound channel 3 always produces so=
me audio artifacts (distortion) when
sound is initialized. Fortunately, switching banks does not require re-init=
ialisation during playback, thus allowing
for dynamic reloading of the Wave Ram without generating any distortion.<br=
>
<br>
Both banks of Wave Ram are filled with zero upon initialization of the Game=
boy, Bank 0 being selected. So writing
to bank 0 implies setting bit 6 to 1 before loading Wave Ram then set it ba=
ck to 0 to play it.<br>
<b><br>
<br>
Address: 0x04000072 - <a name=3D"REG_SOUND3CNT_H"></a>REG_SOUND3CNT_H (Soun=
d 3 Sound length and output level control)(Unimplemented
in CowBite)</b></p>
<pre>                  <font color=3D"#CC9900">W W W W  W W W W</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#9900CC">R R R</font> <font color=3D"#BBBBBB">X  X X X X</fo=
nt> <font color=3D"#FF0099"> L L L L  L L L L</font>

</pre>
<pre>0-7 <font color=3D"#FF0099">(L)</font> =3D Sound length. The sound len=
gth is an 8 bit value obtained from the=20
          following formula:  Register=3DNote length (in seconds)*256
          Hence a 1 second maximum and a 3.9 millisecond minimum sound dura=
tion.
          After the sound length has be changed, the sound channel must be
          resetted via bit F of <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#REG_SOUNDCNT_X">REG_SOUND3CNT_X</a>.=20

D-F <font color=3D"#9900CC">(R)</font> =3D Output volume ratio:
         =20
          000 - Mute
          001 - 100%
          100 - 75%
          010 - 50%
          011 - 25%</pre>
<p><br>
<b>Address: 0x04000074 - <a name=3D"REG_SOUND3CNT_X"></a>REG_SOUND3CNT_X (S=
ound 3 Frequency, reset and loop control)(Unimplemented
in CowBite)</b></p>
<pre><font color=3D"#CC9900">W</font>          <font color=3D"#CC9900">W W =
W  W W W W  W W W W</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#0099FF">R</font> <font color=3D"#9900CC">T</font> <font col=
or=3D"#BBBBBB">X X  X</font> <font color=3D"#FF0099">F F F  F F F F  F F F =
F</font></pre>
<pre>0-A <font color=3D"#FF0099">(F)</font> =3D Sound frequency. The minimu=
m frequency is 64Hz and the maximum is
          131Khz. Can be calculated from the following formula:
          F(hz)=3D4194304/(32*(2048-register value)).

E <font color=3D"#9900CC">(T)</font> =3D Timed sound. When set to 0, sound =
3 is played continuously regardless of
        the length data in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBit=
e/CowBiteSpec.htm#REG_SOUND3CNT_H">REG_SOUND3CNT_H</a>. When set to 1, soun=
d is played for
        that specified length and after that, bit 2 of <a href=3D"http://ww=
w.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SOUNDCNT_X">REG_SOUNDCNT_=
X</a> is reset.

F <font color=3D"#0099FF">(R)</font> =3D Sound reset. When set, sound reset=
s and restarts at the specified
        frequency. Frequency and sound reset must be perfomed in a single w=
rite
        since both are write only. In continuous mode, frequency can be cha=
nged
        without resetting the sound channel.</pre>
<p><br>
<b><br>
Address: 0x04000078 - <a name=3D"REG_SOUND4CNT_L"></a>REG_SOUND4CNT_L (Soun=
d 4 Length, output level and envelope
control)(Unimplemented in CowBite)</b></p>
<pre>                     <font color=3D"#CC9900">W W  W W W W</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#008800">I I I I</font><font color=3D"#0099FF">  M</font> <f=
ont color=3D"#9900CC">T T T</font><font color=3D"#BBBBBB">  X X </font><fon=
t color=3D"#FF0099">L L  L L L L</font>

</pre>
<pre>0-5 <font color=3D"#FF0099">(L)</font> =3D Sound length. This is a 6 b=
it value obtained from the following formula:
          Sound length=3D (64-register value)*(1/256) seconds. After the so=
und length
          has been changed, the sound channel must be resetted via bit F of
          <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#REG_SOUND4CNT_H">REG_SOUND4CNT_H</a> (when using timed mode).=20
8-A <font color=3D"#9900CC">(T)</font> =3D Envelope step time. This is the =
delay between successive envelope
          increase or decrease. It is given by the following formula:=20
          Time=3Dregister value*(1/64) seconds.=20
B   <font color=3D"#0099FF">(M)</font> =3D Envelope mode. Controls if the e=
nvelope is to increase or decrease in volume
          over time.

          0 - Envelope decreases
          1 - Envelope increases</pre>
<pre>D-F <font color=3D"#008800">(I)</font> =3D Initial Envelope value<b>. =
</b>1111 produces the maximum volume and 0000 mutes
          the sound. </pre>
<p><b><br>
<br>
Address: 0x0400007C - <a name=3D"REG_SOUND4CNT_H"></a>REG_SOUND4CNT_H (Soun=
d 4 Noise parameters, reset and loop control)(Unimplemented
in CowBite)</b></p>
<pre><font color=3D"#CC9900">W</font><b>
</b>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#FF3300">R</font> <font color=3D"#008800">T</font> <font col=
or=3D"#BBBBBB">X X  X X X X</font> <font color=3D"#0099FF"> P P P P</font> =
 <font color=3D"#9900CC">S</font> <font color=3D"#FF0099">C C C</font>

</pre>
<pre>0-2 <font color=3D"#FF0099">(C)</font> =3D Clock divider frequency. Th=
is divides the CPU frequency. Its output is
          then fed into the counter's pre-scaler (controlled by bits 4-7) w=
hich
          further devides the frequency.

          000: f*2      f=3D4.194304 Mhz/8
          001: f
          010: f/2
          011: f/3
          100: f/4
          101: f/5
          110: f/6
          111: f/7</pre>
<pre>3 <font color=3D"#9900CC">  (S)</font> =3D Counter stages: 0=3D15 stag=
es, 1=3D7 stages. This controls the period of the
          polynomial counter. It is given by (2^n)-1 where n is the number =
of
          stages. So for n=3D7, the pseudo-noise period lasts 63 input cloc=
ks.
          After that, the counter restarts the same count sequence.=20
4-7 <font color=3D"#0099FF">(P)</font> =3D Counter Pre-Stepper frequency:
         =20
          0000: Q/2
          0001: Q/2^2
          0010: Q/2^3
          0011: Q/2^4
          ....
          1101: Q/2^14
          1110: Not used
          1111: Not used  =20
          Where Q is the clock divider's output frequency</pre>
<pre>E   <font color=3D"#008800">(T)</font> =3D Timed sound. When set to 0,=
 sound 4 is played continuously regardless of
          the length data in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowB=
ite/CowBiteSpec.htm#REG_SOUND4CNT_L">REG_SOUND4CNT_L</a>. When set to 1, so=
und is played for that
          specified length and after that, bit 3 of <a href=3D"http://www.c=
s.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SOUNDCNT_X">REG_SOUNDCNT_X</=
a> is reset.
F <font color=3D"#FF3300">  (R)</font> =3D Sound reset. When bit F is set t=
o 1, Envelope is set to initial value,
          the LFSR count sequence is resetted and the sound restarts.<b> </=
b>In continuous
          mode, all parameters can be changed but the sound needs to be res=
etted when
          modifying the envelope initial volume or the clock divider for ch=
anges to
          take effects. </pre>
<p><b><br>
</b>Channel 4 produces pseudo-noise generated by a polynomial counter. It i=
s based on a 7/15 stages linear-feedback
shift register (LFSR). LFSR counts in a pseudo-random order where each stat=
e is generated once and only once during
the whole count sequence. The sound is produced by the least significant bi=
t's output stage. <b><br>
<br>
<br>
Address: 0x04000080 - <a name=3D"REG_SOUNDCNT_L"></a>REG_SOUNDCNT_L (Sound =
1-4 Output level and Stereo control)(Unimplemented
in CowBite)</b></p>
<pre>                           <font color=3D"#FF0000">?</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#9900CC">R</font> <font color=3D"#FF0099">Q</font> <font col=
or=3D"#FF3300">P</font> <font color=3D"#008800">O</font> <font color=3D"#00=
99FF"> N</font> <font color=3D"#9900CC">M</font> <font color=3D"#FF0099">L<=
/font> <font color=3D"#FF3300">K</font> <font color=3D"#008800"> J</font> <=
font color=3D"#0099FF">I I I</font> <font color=3D"#9900CC"> H</font> <font=
 color=3D"#FF0099">G G G</font>
</pre>
<pre>0-2 <font color=3D"#FF0099">(G)</font> =3D DMG Left Volume
3   <font color=3D"#9900CC">(H)</font> =3D Vin Left on/off (?) - According =
to BeLogic, Vin on/off allowed the
          original GameBoy paks to provide their own sound source. It is un=
kown
          whether they still work on a GBA.
4-6 <font color=3D"#0099FF">(I)</font> =3D DMG Right Volume
7 <font color=3D"#008800">  (J)</font> =3D Vin Right on/off (?)=20
8 <font color=3D"#FF3300">  (K)</font> =3D DMG Sound 1 to left output
9 <font color=3D"#FF0099">  (L)</font> =3D DMG Sound 2 to left output
A <font color=3D"#9900CC">  (M)</font> =3D DMG Sound 3 to left output=20
B <font color=3D"#0099FF">  (N)</font> =3D DMG Sound 4 to left output
C <font color=3D"#008800">  (O)</font> =3D DMG Sound 1 to right output
D <font color=3D"#FF3300">  (P)</font> =3D DMG Sound 2 to right output
E <font color=3D"#FF33CC">  (Q)</font> =3D DMG Sound 3 to right output
F <font color=3D"#9933FF">  (R)</font> =3D DMG Sound 4 to right output </pr=
e>
<p><br>
This register controls only the DMG output amplifiers and have no effects o=
n the individual sound channels' processing,
or Direct Sound channels' volume.<b><br>
<br>
<br>
Address: 0x04000082 - <a name=3D"REG_SOUNDCNT_H"></a>REG_SOUNDCNT_H (Direct=
 Sound control and Sound 1-4 output ratio)(Implemented
in CowBite)</b></p>
<pre><font color=3D"#CC9900">W        W</font>       =20
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#FF0099">Q</font><font color=3D"#FF3300"> P</font> <font col=
or=3D"#008800">O</font> <font color=3D"#0099FF">N</font>  <font color=3D"#9=
900CC">M </font><font color=3D"#FF0099">L</font> <font color=3D"#FF3300">K<=
/font> <font color=3D"#008800">J</font> <font color=3D"#BBBBBB"> X X X X</f=
ont> <font color=3D"#0099FF"> I</font> <font color=3D"#9900CC">H</font> <fo=
nt color=3D"#FF0099">G G</font></pre>
<pre>0-1 <font color=3D"#FF0099">(G)</font> =3D Output Sound Ratio for chan=
nels 1-4.

          00 - 25%
          01 - 50%
          10 - 100%
          11 - ??

2 <font color=3D"#9900CC">  (H)</font> =3D Direct sound A output ratio (0 -=
 50%, 1 - 100%)
3 <font color=3D"#0099FF">  (I)</font> =3D Direct sound B output ratio (0 -=
 50%, 1 - 100%)
8 <font color=3D"#008800">  (J)</font> =3D Direct Sound A to right output
9 <font color=3D"#FF3300">  (K)</font> =3D Direct sound A to left output=20
A <font color=3D"#FF0099">  (L)</font> =3D Direct sound A Sampling rate tim=
er (<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_T=
M0DAT">timer 0</a> or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Cow=
BiteSpec.htm#REG_TM1DAT">1</a>). Use this to set which
          timer contorls the playback frequency.
B <font color=3D"#9900CC">  (M)</font> =3D Direct sound <a href=3D"http://w=
ww.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_FIFO_A_L">A FIFO</a> res=
et=20
C <font color=3D"#0099FF">  (N)</font> =3D Direct sound B to right output=
=20
D <font color=3D"#008800">  (O)</font> =3D Direct sound B to left output=20
E <font color=3D"#FF3300">  (P)</font> =3D Direct sound B Sampling rate tim=
er (<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_T=
M0DAT">timer 0</a> or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Cow=
BiteSpec.htm#REG_TM1DAT">1</a>). Use this to set
          which timer controls the playback frequency.
F <font color=3D"#FF0099">  (Q)</font> =3D Direct sound <a href=3D"http://w=
ww.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_FIFO_B_L">B FIFO</a> res=
et </pre>
<p><br>
This register is used in controlling Direct Sound on the GBA. Output ratios=
 control the volume, in percentage,
that gets output to the speakers.<br>
<br>
<b><br>
Address: 0x04000084 - <a name=3D"REG_SOUNDCNT_X"></a>REG_SOUNDCNT_X (Master=
 sound enable and Sound 1-4 play status)(Partially
Implemented in CowBite)</b></p>
<pre><font color=3D"#FF0000">                           R R R R</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X X</font> <font color=3D"#FF3300"> N<=
/font> <font color=3D"#BBBBBB">X X X</font>  <font color=3D"#008800">J</fon=
t> <font color=3D"#0099FF">I</font> <font color=3D"#9900CC">H</font> <font =
color=3D"#FF0099">G</font>
</pre>
<pre>0 <font color=3D"#FF0099">(G)</font> =3D DMG Sound 1 Status (Read only=
). 0 - Stopped, 1 - Playing
1 <font color=3D"#9900CC">(H)</font> =3D DMG Sound 2 Status (Read only). 0 =
- Stopped, 1 - Playing
2 <font color=3D"#0099FF">(I)</font> =3D DMG Sound 3 Status (Read only). 0 =
- Stopped, 1 - Playing
3 <font color=3D"#008800">(J)</font> =3D DMG Sound 4 Status (Read only). 0 =
- Stopped, 1 - Playing
7 <font color=3D"#FF3300">(N)</font> =3D All Sound circuit enable</pre>
<p><br>
This register is used to monitor the play status of sounds and to turn on o=
r off all sound circuits. Turning the
sound circuits off saves battery power, allowing them to last up to 10% lon=
ger.<br>
<b><br>
<br>
Address: 0x04000088 - <a name=3D"REG_SOUNDBIAS"></a>REG_SOUNDBIAS (Sound bi=
as and Amplitude resolution control)(Unimplemented
in CowBite)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#9900CC">R R</font> <font color=3D"#BBBBBB">X X  X X</font> =
<font color=3D"#FF0099">B B  B B B B  B B B</font><font color=3D"#BBBBBB"> =
X</font></pre>
<pre>1-9 <font color=3D"#FF0099">(B)</font> =3D PWM bias value, controlled =
by the BIOS.<b>
</b>E-F <font color=3D"#9900CC">(R)</font> =3D Amplitude resolutions
          00 - 9 bit at 32768 hz
          01 - 8 bit at 65536 hz
          10 - 7 bit at 131072 hz
          11 - 6 bit at 262144 hz</pre>
<p>The BIAS setting is used to offset the sound output and bring it back in=
to a signed range. When the BIOS starts
up, it runs a timing loop where it slowly raises the BIAS voltage from 0 to=
 512. This setting should not be changed.
At best, the sound will become distorted. At worst the amplifier inside the=
 GBA could be damaged. <br>
<br>
When accessing bits F-E, a read-modify-write is required. The default value=
 for bits F-E is 00. Most if not all
games use 01 for this setting.<br>
<b><br>
<br>
Address: 0x04000090 - <a name=3D"REG_WAVE_RAM0_L"></a>REG_WAVE_RAM0_L (Soun=
d 3 samples 0-3)<br>
Address: 0x04000092 - <a name=3D"REG_WAVE_RAM0_H"></a>REG_WAVE_RAM0_H (Soun=
d 3 samples 4-7)<br>
Address: 0x04000094 - <a name=3D"REG_WAVE_RAM1_L"></a>REG_WAVE_RAM1_L (Soun=
d 3 samples 8-11)<br>
Address: 0x04000096 - <a name=3D"REG_WAVE_RAM1_H"></a>REG_WAVE_RAM1_H (Soun=
d 3 samples 12-15)<br>
Address: 0x04000098 - <a name=3D"REG_WAVE_RAM2_L"></a>REG_WAVE_RAM2_L (Soun=
d 3 samples 16-19)<br>
Address: 0x0400009A - <a name=3D"REG_WAVE_RAM2_H"></a>REG_WAVE_RAM2_H (Soun=
d 3 samples 20-23)<br>
Address: 0x0400009C - <a name=3D"REG_WAVE_RAM3_L"></a>REG_WAVE_RAM3_L (Soun=
d 3 samples 23-27)<br>
Address: 0x0400009E - <a name=3D"REG_WAVE_RAM3_H"></a>REG_WAVE_RAM3_H (Soun=
d 3 samples 28-31)<br>
<br>
</b>These registers together contain four (4 bytes each) 4-bit wave RAM sam=
ples for Sound channel 3.<b><br>
<br>
<br>
Address: 0x040000A0 - <a name=3D"REG_FIFO_A_L"></a>REG_FIFO_A_L (Direct Sou=
nd channel A samples 0-1)(Write Only)<br>
Address: 0x040000A2 - <a name=3D"REG_FIFO_A_H"></a>REG_FIFO_A_H (Direct Sou=
nd channel A samples 2-3)(Write Only)<br>
Address: 0x040000A4 - <a name=3D"REG_FIFO_B_L"></a>REG_FIFO_B_L (Direct Sou=
nd channel B samples 0-1)(Write Only)<br>
Address: 0x040000A6 - <a name=3D"REG_FIFO_B_H"></a>REG_FIFO_B_H (Direct Sou=
nd channel B samples 2-3)(Write Only)</b><br>
<br>
These are the locations of the Direct Sound 8-bit FIFO samples, from which =
Direct Sound pulls the music data to
be played on the speakers. Note that there are only 8 bytes total for all y=
our samples. You repeatedly fill these
from a buffer of your own using <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#REG_DMA0CNT">DMA0</a>
or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_DM=
A1CNT">DMA1</a>, or by using timer <a href=3D"http://www.cs.rit.edu/~tjh830=
0/CowBite/CowBiteSpec.htm#Hardware%20Interrupts">interrupts</a>. <br>
<br>
To fill them using DMA, first set <a href=3D"http://www.cs.rit.edu/~tjh8300=
/CowBite/CowBiteSpec.htm#REG_TM0DAT">Timer
0</a> or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#=
REG_TM1DAT">Timer 1</a> to refresh at
the appropriate sample rate (for example, 16khz). Next, set the <a href=3D"=
http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_DMA0SAD">DMA
source address</a> to a sound sample in memory, and the <a href=3D"http://w=
ww.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_DMA0DST">destination
address</a> to one of these FIFO registers. Use <a href=3D"http://www.cs.ri=
t.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SOUNDCNT_H">REG_SOUNTCNT_H</a>
to reset FIFO and tell Direct Sound to get its sampling rate from Timer 0 o=
r Timer 1. Finally, set the <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBi=
te/CowBiteSpec.htm#REG_DMA0CNT">DMA
control register</a> to start on FIFO empty (start mode 11) and to repeat, =
then enable the timers. All of this
will cause the hardware to play sound samples in FIFO at the rate specified=
 in your timer, and automatically refill
them using DMA.<br>
<br>
To fill these using <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBi=
teSpec.htm#Hardware%20Interrupts">interrupts</a>,
follow a similar process, but instead of using DMA, set the clock to interr=
upt on overflow. When using interrupts
instead of DMA, BeLogic recommends setting the <a href=3D"http://www.cs.rit=
.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_TM0CNT">timer</a>
divider to 1024 and start the timer at 0xFFFF order to get a sampling rate =
of 16.384 khz. This apparently causes
less distortion than if you simply set the start time of the clock to 0xFFF=
F - (2^24/16000).<br>
<br>
Note that reading from these registers can yield unpredictable results. It =
might be interesting to see just <i>how</i>
unpredictable...<br>
<br>

</p><hr align=3D"CENTER">

<h3><b>Addresses: 0x40000B0, 0x40000BC, 0x40000C8, 0x40000D4 (<a name=3D"DM=
A Source Registers"></a>DMA Source Registers)(Write
Only)</b></h3>
<p><b>Address: 0x40000B0 - <a name=3D"REG_DMA0SAD"></a>REG_DMA0SAD (DMA0 So=
urce Address)</b>(Write Only)</p>
<pre>31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  11 10=
 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X  X  X  X   X</font>  <font color=3D"#FF0099">A  A=
  A   A  A  A  A   A  A  A  A   A  A  A  A   A  A  A A  A A A A  A A A A</f=
ont><b>

</b>0-26 <font color=3D"#FF0099">(A)</font> =3D 27-bit source address</pre>
<p>This is the source address for DMA channel 0 transfers. Note that it is =
27-bit.<b><br>
<br>
Address: 0x40000BC - <a name=3D"REG_DMA1SAD"></a>REG_DMA1SAD (DMA1 Source A=
ddress)<br>
Address: 0x40000C8 - <a name=3D"REG_DMA2SAD"></a>REG_DMA2SAD (DMA2 Source A=
ddress)<br>
Address: 0x40000D4 - <a name=3D"REG_DMA3SAD"></a>REG_DMA3SAD (DMA3 Source A=
ddress)</b></p>
<pre>31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  11 10=
 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X  X  X  X  </font><font color=3D"#FF0099"> A  A  A=
  A   A  A  A  A   A  A  A  A   A  A  A  A   A  A  A A  A A A A  A A A A<b>
</b></font><b>
</b>0-27 <font color=3D"#FF0099">(A)</font> =3D 28-bit source address</pre>
<p>This is the source address for DMA channel 1, 2, or 3 transfers. Note th=
at it is 28-bit.
</p><h3><b><br>
Addresses: 0x40000B4, 0x40000C0, 0x40000CC, 0x40000D8 (<a name=3D"DMA Desti=
nation Registers"></a>DMA Destination
Registers</b>) (Write Only)</h3>
<p><b>Address: 0x40000B4 - <a name=3D"REG_DMA0DST"></a>REG_DMA0DAD (DMA0 De=
stination Address)<br>
Address: 0x40000C0 -<a name=3D"REG_DMA1DST"></a> REG_DMA1DAD (DMA1 Destinat=
ion Address) <br>
Address: 0x40000CC - <a name=3D"REG_DMA2DST"></a>REG_DMA2DAD (DMA2 Destinat=
ion Address)</b></p>
<pre>31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  11 10=
 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X  X  X  X   X  </font><font color=3D"#FF0099">A  A=
  A   A  A  A  A   A  A  A  A   A  A  A  A   A  A  A A  A A A A  A A A A</f=
ont><b>

</b>0-27 <font color=3D"#FF0099">(A)</font> =3D 27-bit destination address<=
/pre>
<p>This is the dest address for DMA channel 0, 1, and 2 transfers. Note tha=
t it is 27-bit.<br>
<br>
<br>
<b>Address: 0x40000D8 - <a name=3D"REG_DMA3DST"></a>REG_DMA3DAD (DMA3 Desti=
nation Address)(Write Only)</b></p>
<pre>31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  11 10=
 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X  X  X  X  </font><font color=3D"#FF0099"> A  A  A=
  A   A  A  A  A   A  A  A  A   A  A  A  A   A  A  A A  A A A A  A A A A</f=
ont><b>

</b>0-27 <font color=3D"#FF0099">(A)</font> =3D 28-bit destination address<=
/pre>
<p>This is the dest address for DMA channel 3 transfers. Note that it is 28=
-bit.
</p><h3><b><br>
Addresses: 0x40000B8, 0x40000C4, 0x40000D0, 0x40000DC (<a name=3D"DMA Count=
 Registers"></a>DMA Count Registers)</b>(Write
Only)</h3>
<p><b>Address: 0x40000B8 - <a name=3D"REG_DMA0SIZE"></a>REG_DMA0CNT_L (DMA0=
 Count Register)<br>
Address: 0x40000C4 - <a name=3D"REG_DMA1SIZE"></a>REG_DMA1CNT_L (DMA1 Count=
 Register)<br>
Address: 0x40000D0 - <a name=3D"REG_DMA2SIZE"></a>REG_DMA2CNT_L (DMA2 Count=
 Register)<br>
Address: 0x40000DC - <a name=3D"REG_DMA3SIZE"></a>REG_DMA3CNT_L (DMA3 Count=
 Register)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X</font> <font color=3D"#FF0099">L L  L L L L  L =
L L L  L L L L</font> </pre>
<pre>0-D <font color=3D"#FF0099">(L)</font> =3D Number of words or halfword=
s to copy</pre>
<p><br>
(Note: In some places you will see the <a href=3D"http://www.cs.rit.edu/~tj=
h8300/CowBite/CowBiteSpec.htm#DMA%20Control%20Registers">DMA
control</a> and DMA count registers depicted as a single 32-bit register ca=
lled REG_DMAXCNT. I opted to treat them
as two 16-bit registers for sake of clarity.)
</p><h3><b>Addresses: 0x40000BA, 0x40000C6, 0x40000D2, 0x40000DE (<a name=
=3D"DMA Control Registers"></a>DMA Control Registers)</b></h3>
<p><b>Address: 0x40000BA - <a name=3D"REG_DMA0CNT"></a>REG_DMA0CNT_H (DMA0 =
Control Register) <br>
Address: 0x40000C6 -<a name=3D"REG_DMA1CNT"></a>REG_DMA1CNT_H (DMA1 Control=
 Register) <br>
Address: 0x40000D2 - <a name=3D"REG_DMA2CNT"></a>REG_DMA2CNT_H (DMA2 Contro=
l Register) <br>
Address: 0x40000DE - <a name=3D"REG_DMA3CNT"></a>REG_DMA3CNT_H (DMA3 Contro=
l Register)</b></p>
<pre><font color=3D"#FF0000">         ?             </font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#0099FF">N </font><font color=3D"#9900CC">I </font><font col=
or=3D"#FF0099">M M </font><font color=3D"#FF3300"> U</font> <font color=3D"=
#008800">S</font> <font color=3D"#0099FF">R</font> <font color=3D"#9900CC">=
A  A</font> <font color=3D"#FF0099">B B</font> <font color=3D"#BBBBBB">X  X=
 X X X</font>=20

</pre>
<pre>(Note: In some places you will see the DMA control and <a href=3D"http=
://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#DMA%20Count%20Registers"=
>DMA count</a> registers
depicted as a single 32-bit register called REG_DMAXCNT. I opted to treat
them as two 16-bit registers for sake of clarity.)

5-6 <font color=3D"#FF0099">(B)</font> =3D Type of increment applied to des=
tination address. If enabled, the
          address will be incremented/decremented by 2 or 4 bytes, dependin=
g on
          the selected size. When the DMA is activated, the contents of the=
se
          registers are copied to internal counters in the DMA hardware, wh=
ich
          then increments/decrements these registers during transfer, prese=
rving
          the contents of the IORAM registers.<a href=3D"http://www.cs.rit.=
edu/~tjh8300/CowBite/CowBiteSpec.htm#DMANote">*</a>

          00: Increment after each copy=20
          01: Decrement after each copy=20
          10: Leave unchanged=20
          11: Increment without after each copy, reset to initial value at =
the
              end of transfer (or at the end of the current repetition)

7-8 <font color=3D"#9900CC">(A)</font> =3D Type of increment applied to sou=
rce address:
          00: Increment after each copy
          01: Decrement after each copy=20
          10: Leave unchanged=20
          11: Illegal

          Note: I am somewhat uncertain about option "11" for both of these=
.
          Can anyone confirm?=20

9   <font color=3D"#0099FF">(R)</font> =3D Repeat. When in start modes 1 or=
 2, this bit causes the transfer to
          repeat for each interval.=20
A <font color=3D"#008800">  (S)</font> =3D Size. If set, copy 32-bit quanti=
ties (words) If clear, copy 16-bit
          quantities (half words)=20
B <font color=3D"#FF3300">  (U)</font> =3D Unknown.  For DMA 0, 1, and 2, t=
his bit is read only and set to 0. However,
          for DMA 3, it appears to be writeable. Thoughts, anyone?
C-D <font color=3D"#FF0099">(M)</font> =3D Start Mode.
         =20
          00: Transfer immediately=20
          01: Transfer on vblank (i.e. vdma)
          10: Transfer on hblank (i.e. hdma.  Note that, unlike h-interrupt=
s,
                                  hdma does NOT occur during vblank.)
          11: The function of this varies based on the DMA channel.

              For DMA 1 or 2: Instructs the DMA to repeat on FIFO-empty req=
uests.
              When this is set the size and count are ignored and a single =
32 bit
              quantity is transferred on FIFO empty.
              For DMA 3: Apparently allows transfers to start at the beginn=
ing of a
              rendering line, copying data into a buffer as the line is bei=
ng drawn
              on the screen. Useful for flicker-free transfers in mode 3, w=
hich has
              no backbuffer.

E <font color=3D"#9900CC">  (I)</font> =3D IRQ. Setting this bit causes the=
 DMA to generate an <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBi=
teSpec.htm#Hardware%20Interrupts">interrupt</a> when it is
          done with the data transfer.
F <font color=3D"#0099FF">  (N)</font> =3D Set this bit to enable DMA opera=
tion. Clear to end DMA operation.</pre>
<p><br>
This address controls a DMA transfer which allows large amounts of data to =
be transferred from one area of memory
to another. It is theoretically twice as fast as transfering by the CPU, wh=
ich uses at least one cycle for a read
instruction and another for a write. DMA can also be used to clear memory t=
o a constant value, if the source address
is not incremented with each copy. Fist, set the <a href=3D"http://www.cs.r=
it.edu/~tjh8300/CowBite/CowBiteSpec.htm#DMA%20Source%20Registers">DMASAD</a=
>
and <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#DMA%2=
0Destination%20Registers">DMADAD</a> registers
to point to the addresses you want. Writing to DMACNT_H address with a '1' =
in the N field and a '00' in the M field
will start the transfer immediately. <br>
<br>
DMA transfers may occur on an interrupt if the start mode bits are set for =
this. DMAs have a priority ranking with
3 at the lowest and 0 at the highest. For most cases, program code will be =
using DMA3 as it is lowest priority,
allowing it to be interrupted by more important DMA (see below).<br>
<br>
Specific DMAs have the following properties:<br>
<br>
<a name=3D"DMA0"></a><b>DMA0</b>: This DMA is the highester priority, but c=
annot be used to access cartridge memory
(addresses 0x8000000 and higher). It is suitable for time-critical operatio=
ns such as transfering scale and rotate
data to the background scaling registers. Since it takes precedence over ot=
her DMAs, it will not be postponed or
interrupted (possibly causing undesirable results such as screen artifacts)=
.<br>
<br>
<a name=3D"DMA1"></a><b>DMA1</b> and <a name=3D"DMA2"></a><b>DMA2</b>: Thes=
e are the only DMA that can be used for
sound FIFO. If start mode "11" is set, the DMA will be triggered on FIFO em=
pty. I believe that FIFO A
always sends its empty requests to DMA1 and that FIFO B sends its empty req=
uests only to DMA2, though I don't have
any verification of this.<br>
<br>
<a name=3D"DMA3"></a><b>DMA3</b>: This is is the lowest priority and thus o=
ften used as a "general purpose"
DMA. Using this DMA for your basic memory transfers ensures that sound FIFO=
 DMA and other time-critical DMA are
not delayed, making audio or visual artifacts less likely.<br>
<br>
<a name=3D"DMANote"></a>* (Originally I had assumed a direct mapping betwee=
n the source/destination registers and
the current transfer address, and thus this section of the doc distinguishe=
d between transfers which wrote-back
to the registers and those which did not. This appears to have been an inco=
rrect assumption, and was brought to
light as I delved further into sound emulation)
</p><h3><br>
DMA Transfer Ratings</h3>
<p><br>
The following table lists the cycle timings for various DMA transfers. The =
format of each entry is :</p>
<pre><font color=3D"#CC9900">16 bit DMA</font> / <font color=3D"#CC3300">32=
 bit DMA</font></pre>
<p>Units are in <i>cycles per item transfered</i>. Thus, a rating of <font =
color=3D"#CC9900">4</font>/<font color=3D"#CC3300">8</font>
indicates that the transfer takes 4 cycles for every 16 bits transferred wi=
th 16 bit DMA, or 8 cycles for every
32 bits transfered with 32 bit DMA.</p>
<pre><b>Source       Destination</b>
             EWRAM    IWRAM    IO       PAL RAM  VRAM     OAM
ROM 0 WS     <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">8</fo=
nt>      <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font> =
     <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>     =
 <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">4</font>      <fo=
nt color=3D"#CC9900">2</font>/<font color=3D"#CC3300">4</font>      <font c=
olor=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>
ROM 1 WS     <font color=3D"#CC9900">5</font>/<font color=3D"#CC3300">10</f=
ont>     <font color=3D"#CC9900">3</font>/<font color=3D"#CC3300">5</font> =
     <font color=3D"#CC9900">3</font>/<font color=3D"#CC3300">5</font>     =
 <font color=3D"#CC9900">3</font>/<font color=3D"#CC3300">6</font>      <fo=
nt color=3D"#CC9900">3</font>/<font color=3D"#CC3300">6</font>      <font c=
olor=3D"#CC9900">3</font>/<font color=3D"#CC3300">5</font>
ROM 2 WS     <font color=3D"#CC9900">6</font>/<font color=3D"#CC3300">12</f=
ont>     <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</font> =
     <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</font>     =
 <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">8</font>      <fo=
nt color=3D"#CC9900">4</font>/<font color=3D"#CC3300">8</font>      <font c=
olor=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</font>
EWRAM        <font color=3D"#CC9900">6</font>/<font color=3D"#CC3300">12</f=
ont>     <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</font> =
     <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</font>     =
 <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">8</font>      <fo=
nt color=3D"#CC9900">4</font>/<font color=3D"#CC3300">8</font>      <font c=
olor=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</font>
IWRAM        <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</fo=
nt>      <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font> =
     <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font>     =
 <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>      <fo=
nt color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>      <font c=
olor=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font>
I/O          <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</fo=
nt>      <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font> =
     <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font>     =
 <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>      <fo=
nt color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>      <font c=
olor=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font>
PAL RAM      <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">8</fo=
nt>      <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font> =
     <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>     =
 <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">4</font>      <fo=
nt color=3D"#CC9900">2</font>/<font color=3D"#CC3300">4</font>      <font c=
olor=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font>
VRAM         <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">8</fo=
nt>      <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font> =
     <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>     =
 <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">4</font>      <fo=
nt color=3D"#CC9900">2</font>/<font color=3D"#CC3300">4</font>      <font c=
olor=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font>
OAM          <font color=3D"#CC9900">4</font>/<font color=3D"#CC3300">7</fo=
nt>      <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font> =
     <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font>     =
 <font color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>      <fo=
nt color=3D"#CC9900">2</font>/<font color=3D"#CC3300">3</font>      <font c=
olor=3D"#CC9900">2</font>/<font color=3D"#CC3300">2</font>
</pre>
<p>Note that it is not possible to DMA transfer from or to SRAM (Cart RAM) =
or BIOS, and (obviously) it is not possible
to transfer to ROM.<br>
<br>
Thanks to Kay for supplying these transfer statistics!!
</p><h3><br>

<hr align=3D"CENTER">
<br>
Addresses: 0x4000100 - 0x400010E (<a name=3D"Timer registers"></a>Timer reg=
isters)</h3>
<p><b>Address: 0x4000100 - <a name=3D"REG_TM0DAT"></a>REG_TM0D (Timer 0 Dat=
a)<br>
Address: 0x4000104 - <a name=3D"REG_TM1DAT"></a>REG_TM1D (Timer 1 Data)<br>
Address: 0x4000108 - <a name=3D"REG_TM2DAT"></a>REG_TM2D (Timer 2 Data)<br>
Address: 0x400010C - <a name=3D"REG_TM3DAT"></a>REG_TM3D (Timer 3 Data)</b>=
</p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#FF0099">D D D D  D D D D  D D D D  D D D D</font></pre>
<pre>0-F <font color=3D"#FF0099">(D)</font> =3D Current count of the timer.=
</pre>
<p><br>
Note that these registers are R/W. The default is to start counting from 0x=
0000, but if a value is written to this
register, the timer will henceforth use that as a starting value. Thus the =
rate at which timers overflow and generate
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Hardware%=
20Interrupts">interrupts</a> (see <a href=3D"http://www.cs.rit.edu/~tjh8300=
/CowBite/CowBiteSpec.htm#REG_TM0CNT">REG_TMXCNT</a>,
below) can be customized.<b><br>
<br>
</b>Timer 0 and Timer 1 are used to control the rate of Direct Sound FIFO. =
When using <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.ht=
m#REG_DMA0CNT">DMA</a>
with start mode 11, they can automatically cause it to refill the FIFO. To =
set the rate of playback in hz, write
the value 0xFFFF - (2^24/Plaback Freq in hz) to the register. This sets the=
 start value such that the timer will
overflow precisely when the next sound sample is needed, and cause the DMA =
to activate. When using interrupts,
set the start value of these to 0, but use <a href=3D"http://www.cs.rit.edu=
/~tjh8300/CowBite/CowBiteSpec.htm#REG_TM0CNT">REG_TMXCNT</a>
to change the update frequency to 1024, thus causing an interrupt rate of 1=
6.384khz.<br>
<br>
<b><br>
Address: 0x4000102 - <a name=3D"REG_TM0CNT"></a>REG_TM0CNT (Timer 0 Control=
)<br>
Address: 0x4000106 - <a name=3D"REG_TM1CNT"></a>REG_TM1CNT (Timer 1 Control=
)<br>
Address: 0x400010A - <a name=3D"REG_TM2CNT"></a>REG_TM2CNT (Timer 2 Control=
)<br>
Address: 0x400010E - <a name=3D"REG_TM3CNT"></a>REG_TM3CNT (Timer 3 Control=
)</b></p>
<pre><font color=3D"#FF0000">                             *</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X X</font><font color=3D"#008800">  E =
</font><font color=3D"#0099FF">I</font> <font color=3D"#BBBBBB">X X  X</fon=
t> <font color=3D"#9900CC">C </font><font color=3D"#FF0099">F F</font></pre=
>
<pre>0-1 <font color=3D"#FF0099">(F)</font> =3D Frequency at which the time=
r updates.

          00: Default frequency (full) - 16.78MHz (~17mlns ticks per second=
)
          01: Every 64 clock pulses - ~262187.5KHz
          10: Every 256 clock pulses - ~65546.875KHz
          11: Every 1024 clock pulses - ~16386.71875KHz

2   <font color=3D"#9900CC">(C)</font> =3D Cascade (<font color=3D"#DD0000"=
>*</font> Unused on TM0) - When this bit is set, the frequency of this
          timer is ignored. Instead the timer increments when the timer bel=
ow it
          overflows. For example, if timer 1 is set to cascade, it will inc=
rement
          whenever timer 0's value goes from 0xFFFF to 0x0000.
6   <font color=3D"#0099FF">(I)</font> =3D Generate an interrupt on overflo=
w
7 <font color=3D"#008800">  (E)</font> =3D Enable the timer.</pre>
<h3><br>

<hr align=3D"CENTER">
<br>
Addresses 0x4000120 - 0x400012A - <a name=3D"Serial Communication Registers=
"></a>Serial Communication Registers)
(Unimplemented in CowBite)</h3>
<p>Using the link port and a link cable, the GBA can transmit serial data i=
n one of five modes: Normal, Multilink,
JOY BUS, General-Purpose, and UART. The function of the serial communicatio=
n registers changes significantly depending
on the mode. Thus each of these registers comes has several different discr=
iptions associated with it, listed under
the associated mode.<br>
<br>
Note: The serial comm information originates primarily from Martin Korth's =
<a href=3D"http://www.work.de/nocash/gba.htm">no$gba</a>
documentation, which is the most thorough explanation of GBA serial comm th=
at I've read anywhere. My original info
on Multiplayer mode originates from <a href=3D"http://members.truepath.com/=
AndrewMay/GBA.html">Andrew May's description</a>
of the GBA linker hardware, which ePAc for discovered and put into a format=
 consistent with the rest of this spec<b><br>
<br>
Address: 0x4000120 - <a name=3D"REG_SCD0"></a>REG_SCD0 <br>
Address: 0x4000122 - <a name=3D"REG_SCD1 "></a>REG_SCD1<br>
Address: 0x4000124 - <a name=3D"REG_SCD2"></a>REG_SCD2 <br>
Address: 0x4000126 - <a name=3D"REG_SCD3"></a>REG_SCD3<br>
<br>
Normal Mode (0x4000120 and 0x4000122 only)</b></p>
<pre>31 30 29 28  27 26 25 24  23 22 21 20  19 18 17 16  15 14 13 12  11 10=
 9 8  7 6 5 4  3 2 1 0
<font color=3D"#FF0099">D  D  D  D  </font><font color=3D"#BBBBBB"> </font>=
<font color=3D"#FF0099">D  D  D  D   D  D  D  D   D  D  D  D   D  D  D  D  =
 D  D  D D  D D D D  D D D D</font><b>
</b>
0-31 <font color=3D"#FF0099">(D)</font> =3D The 32-bit data to sent/receive=
d over the link cable.</pre>
<p>For 32-bit normal mode only. Contains 32-bit data. Outgoing data should =
be written to this register before starting
the transfer. During transfer, transmitted bits are shifted-out (MSB first)=
, and received bits are shifted-in simultaneously.
Upon transfer completion, the register contains the received 32-bit value.<=
/p>
<pre></pre>
<p><b><br>
Multi-Player Mode</b></p>
<pre><font color=3D"#FF0000">R R R R  R R R R  R R R R  R R R R</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#FF0099">D D D D  D D D D  D D D D  D D D D</font>
</pre>
<pre>0-F <font color=3D"#FF0099">(D)</font> =3D The data received.</pre>
<p>- SCD0 contains the data sent by the master (also called slave 0)<br>
- SCD1 contains the data sent by the first slave (slave1)<br>
- SCD2 contains the data sent by the second slave (slave2)<br>
- SCD3 contains the data sent by the last slave (slave3)<br>
<br>
These registers are automatically reset ot 0xFFFF on transfer start. After =
transfer, they contain the incoming
data from all linked GBAs (including data from the local machine).<br>
<br>
<b><br>
Address: 0x4000128 - <a name=3D"REG_SCCNT_L"></a>REG_SCCNT_L (Serial Commun=
ication channel control register)</b></p>
<p><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Normal=
%20Mode"><b>Normal Mode</b></a><b><br>
</b><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Multi=
link%20Mode"><b>Multiplayer Mode</b></a><b><br>
</b><a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#UART%=
20Mode"><b>UART Mode</b></a><b><br>
<br>
<a name=3D"Normal Mode"></a>Normal Mode</b></p>
<pre><font color=3D"#FF0000">                             R              </=
font>  =20
F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X </font><font color=3D"#9900CC">I</font> <font col=
or=3D"#FF0099">M M</font> <font color=3D"#BBBBBB"> X X X X </font><font col=
or=3D"#FF3300"> S</font> <font color=3D"#BBBBBB">X X X</font> <font color=
=3D"#9900CC"> </font><font color=3D"#DD0000">N</font><font color=3D"#9900CC=
"> L</font> <font color=3D"#008800">C</font><font color=3D"#FF0099"> B</fon=
t></pre>
<pre>0 <font color=3D"#FF0099">  (B)</font> =3D Shift Clock (SC) (0 - Exter=
nal, 1 - Internal)
1   <font color=3D"#008800">(C)</font> =3D Internal Shift Clock (0 - 256khz=
, 1 - 2 MHz)
2   <font color=3D"#9900CC">(L)</font> =3D SI State (opponents SO) (0 - Low=
, 1 - High/None)
3   <font color=3D"#DD0000">(N)</font> =3D SO during inactivity (0 - Low, 1=
 - High)
7 <font color=3D"#FF3300">  (S)</font> =3D Start/Busy bit (0 - inactive/rea=
dy, 1 - start/active)
C-D <font color=3D"#FF0099">(M)</font> =3D Comm Mode [8bit=3D00,32bit=3D01,=
Multiplayer=3D10,UART=3D11]
E <font color=3D"#9900CC">  (I)</font> =3D Interrupt on completion</pre>
<p><br>
The following is from Martin Korth's no$gba docs:<br>
<br>
Recommended Communication Procedure for SLAVE unit (external clock)<br>
- Initialize data which is to be sent to master (placed in <a href=3D"http:=
//www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SCCNT_H">REG_SCCNT_H<=
/a>
for 8-bit mode or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBite=
Spec.htm#REG_SCD0">REG_SCD0</a> for 32-bit
mode<b>)</b><br>
- Set Start bit (bit 7)<br>
- Set SO to LOW to indicate that master may start now.<br>
- Wait for IRQ (or for Start bit to become zero). (Check timeout here!)<br>
- Set SO to HIGH to indicate that we are not ready.<br>
- Process received data (received in <a href=3D"http://www.cs.rit.edu/~tjh8=
300/CowBite/CowBiteSpec.htm#REG_SCCNT_H">REG_SCCNT_H</a>
for 8-bit mode or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBite=
Spec.htm#REG_SCD0">REG_SCD0</a> for 32-bit
mode<b>)</b><br>
<br>
Recommended Communication Procedure for MASTER unit (internal clock)<br>
- Initialize data which is to be sent to slave (placed in <a href=3D"http:/=
/www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SCCNT_H">REG_SCCNT_H</=
a>
for 8-bit mode or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBite=
Spec.htm#REG_SCD0">REG_SCD0</a> for 32-bit
mode<b>)</b><br>
- Wait for SI to become LOW (slave ready). (Check timeout here!)<br>
- Set Start flag.<br>
- Wait for IRQ (or for Start bit to become zero).<br>
- Process received data (received in <a href=3D"http://www.cs.rit.edu/~tjh8=
300/CowBite/CowBiteSpec.htm#REG_SCCNT_H">REG_SCCNT_H</a>
for 8-bit mode or <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBite=
Spec.htm#REG_SCD0">REG_SCD0</a> for 32-bit
mode<b>)</b><br>
<br>
Martin also notes that that when more than two GBAs are connected, data is =
rotated from the first to the last GBA
rather than just being swapped between the first and second in the chain. F=
or a more detailed description, see
the help files included in <a href=3D"http://www.work.de/nocash/gba.htm">no=
$gba</a>.<br>
<font color=3D"#FF0000"><br>
<br>
<a name=3D"Multilink Mode"></a></font><b>Multi-Player Mode</b></p>
<pre><font color=3D"#FF0000">                  </font><font color=3D"#FF330=
0">*</font><font color=3D"#FF0000"> R R R  R R              </font>  =20
F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X </font><font color=3D"#9900CC">I</font> <font col=
or=3D"#FF0099">M M</font> <font color=3D"#BBBBBB"> X X X X </font><font col=
or=3D"#FF3300"> S</font> <font color=3D"#008800">E</font> <font color=3D"#0=
099FF">D D</font> <font color=3D"#9900CC"> </font><font color=3D"#DD0000">N=
</font><font color=3D"#9900CC"> L</font> <font color=3D"#FF0099">B B</font>=
</pre>
<pre>0-1 <font color=3D"#FF0099">(B)</font> =3D Baud rate [00=3D9600,01=3D3=
8400,10=3D57600,11=3D115200]
2   <font color=3D"#9900CC">(L)</font> =3D SI-Terminal (0 - Parent, 1- Chil=
d)
3   <font color=3D"#DD0000">(N)</font> =3D SD-Terminal (0 - Bad connection,=
 1 - All GBAs Ready)
4-5 <font color=3D"#0099FF">(D)</font> =3D ID of GBA [00=3Dmaster,01=3Dslav=
e1,10=3Dslave2,11=3Dslave3]
6   <font color=3D"#008800">(E)</font> =3D Error (1 on error)
7 <font color=3D"#FF3300">  (S)</font> =3D Start/Busy bit (1 triggers the s=
tart on the master, signifies busy on slaves)
          <font color=3D"#FF3300">*</font> Read only on slaves
C-D <font color=3D"#FF0099">(M)</font> =3D Comm Mode [8bit=3D00,32bit=3D01,=
Multiplayer=3D10,UART=3D11]
E <font color=3D"#9900CC">  (I)</font> =3D Interrupt on completion</pre>
<p><br>
To transfer data in this mode, you must coordinate the actions of all the G=
BAs which are linked together. First
set the mode bits in <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowB=
iteSpec.htm#REG_R">REG_RCNT</a> and in
this register. Each GBA slave must place the data they wish transfered in <=
a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SCCNT_=
H">REG_SCCNT_H</a>.
Then the Master/Slave 0 initiates the transfer by setting bit 7 of REG_SCCN=
T_L. This causes the hardware to transfer
the data. It will magically appear in the destination registers of each sla=
ve, according to the following:<br>
<br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SCCNT=
_H">REG_SCCNT_H</a> from GBA with id 00
goes into <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#REG_SCD0">REG_SCD0</a> on each GBA<br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SCCNT=
_H">REG_SCCNT_H</a> from GBA with id 01
goes into <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#REG_SCD0">REG_SCD1</a> on each GBA<br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SCCNT=
_H">REG_SCCNT_H</a> from GBA with id 10
goes into <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#REG_SCD0">REG_SCD2</a> on each GBA<br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_SCCNT=
_H">REG_SCCNT_H</a> from GBA with id 11
goes into <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm=
#REG_SCD0">REG_SCD3</a> on each GBA<br>
<br>
Thus each GBA in the chain has a duplicate of the data. <br>
<br>
ePAc has commented that the master is the GBA in the set that has the purpl=
e connector connected to its ext port.
So if you have a GBA that want to be a MBserver for a set of clients, then =
you need to put the cart in the one
with the purple connector. It is unclear to me how the other GBAs know what=
 ID they are; perhaps this is also set
according to the link cable connector? <br>
<br>
<b><br>
<a name=3D"UART Mode"></a>UART Mode</b></p>
<pre><font color=3D"#FF0000">                    R R R</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X </font><font color=3D"#9900CC">I</font> <font col=
or=3D"#FF0099">M M</font> <font color=3D"#BBBBBB"> </font><font color=3D"#0=
08800">U</font><font color=3D"#BBBBBB"> </font><font color=3D"#0099FF">T</f=
ont><font color=3D"#BBBBBB"> </font><font color=3D"#9900CC">A</font><font c=
olor=3D"#BBBBBB"> </font><font color=3D"#FF0099">F</font><font color=3D"#BB=
BBBB"> </font><font color=3D"#FF3300"> S</font> <font color=3D"#008800">E</=
font> <font color=3D"#FF0099">R</font><font color=3D"#0099FF"> S</font><b> =
</b><font color=3D"#9900CC"> P </font><font color=3D"#FF3300">C </font><fon=
t color=3D"#FF0099">B B</font></pre>
<pre>0-1 <font color=3D"#FF0099">(B)</font> =3D Baud rate [00=3D9600,01=3D3=
8400,10=3D57600,11=3D115200]
2   <font color=3D"#9900CC">(C)</font> =3D CTS Flag (0 - Send always, 1- Se=
nd only when SC =3D LOW)
3   <font color=3D"#DD0000">(P)</font> =3D Parity Control (0 - Even, 1 - Od=
d)
4   <font color=3D"#0099FF">(S)</font> =3D Send Data Flag (0 - Not full, 1 =
- Full)
5   <font color=3D"#FF0099">(R)</font> =3D Receive Data Flag (0 - Not empty=
, 1 - Empty)
6   <font color=3D"#008800">(E)</font> =3D Error (1 on error)
7 <font color=3D"#FF3300">  (L)</font> =3D Data Length (0 - 7 bits, 1 - 8 b=
its)
8   <font color=3D"#FF0099">(F)</font> =3D FIFO Enable Flag
9   <font color=3D"#9900CC">(A)</font> =3D Parity Enable Flag
10  <font color=3D"#0099FF">(T)</font> =3D Send Enable Flag
11  <font color=3D"#008800">(U)</font> =3D Receieve Enable Flag
C-D <font color=3D"#FF0099">(M)</font> =3D Comm Mode [8bit=3D00,32bit=3D01,=
Multiplayer=3D10,UART=3D11]
E <font color=3D"#9900CC">  (I)</font> =3D Interrupt (0 - Disable, 1 - IRQ =
when bits 4,5, or 6 become set)</pre>
<p><br>
To send data in UART mode:<br>
The receiver outputs SD=3DLOW (which is input as SC=3DLOW at the remote sid=
e) when it is ready to receive data (that
is, when Receive Enable is set, and the Receive shift register (or receive =
FIFO) isn't full.<br>
When CTS flag is set to always/blindly, then the sender transmits data imme=
diately when Send Enable is set, otherwise
data is transmitted only when Send Enable is set and SC is LOW.<br>
<br>
The error flag is set when a bad stop bit has been received (stop bit must =
be 0), when a parity error has occured
(if enabled), or when new data has been completely received while the recei=
ve data register (or receive FIFO) is
already full.<br>
<br>
The error flag is automatically reset when reading from this register.<br>
<br>
Init &amp; Initback<br>
The content of the FIFO is reset when FIFO is disabled in UART mode, thus, =
when entering UART mode initially set
FIFO=3Ddisabled.<br>
The Send/Receive enable bits must be reset before switching from UART mode =
into another SIO mode!<b><br>
<br>
JOY BUS and General-Purpose</b><font color=3D"#FF0000"> <br>
</font><br>
This register is not used in these modes.</p>
<pre></pre>
<p><b><br>
<br>
Address: 0x400012A - <a name=3D"REG_SCCNT_H"></a>REG_SCCNT_H (Serial Commun=
ication Source Register)</b></p>
<p>As with the other serial registers, this info comes from the no$gba docu=
mentation.<b><br>
<br>
Normal</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X X  </font><font color=3D"#FF33CC">S =
S S S  S S S S</font></pre>
<pre>0-7 <font color=3D"#FF0099">(S)</font> =3D The 8-bit data to sent/rece=
ived over the link cable.</pre>
<p>For 8-bit normal mode only. Contains 8-bit data (only the lower 8bit are=
 used). Outgoing data should be written
to this register before starting the transfer. During transfer, transmitted=
 bits are shifted-out (MSB first), and
received bits are shifted-in simultaneously. Upon transfer completion, the =
register contains the received 8-bit
value.<b><br>
<br>
Multiplayer</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#FF33CC">S S S S  S S S S  S S S S  S S S S</font></pre>
<pre>0-F <font color=3D"#FF0099">(S)</font> =3D The 16-bit data to be sent =
over the link cable.
</pre>
<p><b>UART</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X X  </font><font color=3D"#FF33CC">S =
S S S  S S S S</font></pre>
<pre>0-7 <font color=3D"#FF0099">(S)</font> =3D The 8-bit data to sent/rece=
ived over the link cable.</pre>
<p>This is the send/receive shift register, or (when FIFO is used) the send=
/receive FIFO. The send/receive FIFO
may store up to four 8-bit data units each. For example, while 1 unit is st=
ill being transferred from the send
shift register, it is possible to deposit another 4 units in the send FIFO,=
 which are then automatically moved
to the send shift register one after each other.</p>
<pre></pre>
<h3><br>

<hr align=3D"CENTER">
<br>
Addresses 0x4000130 - 0x4000132 - <a name=3D"Keypad input and control regis=
te"></a>Keypad Input and Control Registers</h3>
<p><br>
<b>Address: 0x4000130 - <a name=3D"REG_KEY"></a>REG_KEY (The input register=
)(Read Only)</b></p>
<pre><font color=3D"#FF0000">             R R  R R R R  R R R R</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X</font> <font color=3D"#FF3300">J </fon=
t><font color=3D"#008800">I</font><font color=3D"#0099FF">  D</font> <font =
color=3D"#9900CC">U</font> <font color=3D"#FF0099">L</font> <font color=3D"=
#FF3300">R</font> <font color=3D"#008800"> S</font><font color=3D"#0099FF">=
 E</font> <font color=3D"#9900CC">B</font> <font color=3D"#FF0099">A</font>=
 </pre>
<pre>0 <font color=3D"#FF0099">(A)</font> =3D A button=20
1 <font color=3D"#9900CC">(B)</font> =3D B button=20
2 <font color=3D"#0099FF">(E)</font> =3D Select button=20
3 <font color=3D"#008800">(S)</font> =3D Start button=20
4 <font color=3D"#FF3300">(R)</font> =3D D-pad Right=20
5 <font color=3D"#FF0099">(L)</font> =3D D-pad Left=20
6 <font color=3D"#9900CC">(U)</font> =3D D-pad Up=20
7 <font color=3D"#0099FF">(D)</font> =3D D-pad Down=20
8 <font color=3D"#008800">(I)</font> =3D Right shoulder button=20
9 <font color=3D"#FF3300">(J)</font> =3D Left shoulder button </pre>
<p><br>
This register stores the state of the GBA's buttons. Each of the inputs is =
active low. This means that a '0' bit
indicates that the key is pressed, while a '1' bit indicates that the key i=
s not pressed. In general a game which
samples these (rather than using interrupts) should do so at least once eve=
ry refresh (60hz), or more in the case
of fast action fighting games (like Street Fighter).<br>
<br>
<b>Address: 0x4000132 - <a name=3D"REG_KEYCNT"></a>REG_P1CNT (Key Control R=
egister - As yet unimplemented in CowBite)</b></p>
<pre>   =20
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#9900CC">T</font> <font color=3D"#FF0099">K</font> <font col=
or=3D"#BBBBBB">X X  X X </font><font color=3D"#FF3300">J </font><font color=
=3D"#008800">I</font><font color=3D"#0099FF">  D</font> <font color=3D"#990=
0CC">U</font> <font color=3D"#FF0099">L</font> <font color=3D"#FF3300">R</f=
ont> <font color=3D"#008800"> S</font><font color=3D"#0099FF"> E</font> <fo=
nt color=3D"#9900CC">B</font> <font color=3D"#FF0099">A</font>=20

</pre>
<pre>0 <font color=3D"#FF0099">(A)</font> =3D A button=20
1 <font color=3D"#9900CC">(B)</font> =3D B button=20
2 <font color=3D"#0099FF">(E)</font> =3D Select button=20
3 <font color=3D"#008800">(S)</font> =3D Start button=20
4 <font color=3D"#FF3300">(R)</font> =3D D-pad Right=20
5 <font color=3D"#FF0099">(L)</font> =3D D-pad Left=20
6 <font color=3D"#9900CC">(U)</font> =3D D-pad Up=20
7 <font color=3D"#0099FF">(D)</font> =3D D-pad Down=20
8 <font color=3D"#008800">(I)</font> =3D Right shoulder button=20
9 <font color=3D"#FF3300">(J)</font> =3D Left shoulder button=20
E <font color=3D"#FF0099">(K)</font> =3D generate interrupt on keypress
F <font color=3D"#9900CC">(T)</font> =3D interrupt "type"
        0: "OR" operation -- interrupt will be generated if _any_ of specif=
ied
           keys (bits 0-9) is pressed
        1: "AND" operation, interrupt will be generated if _all_ specified =
keys
           are pressed at the same time.</pre>
<p>Use this register to set which keypresses generate interrupts. The appro=
priate bits must also be set in <a href=3D"http://www.cs.rit.edu/~tjh8300/C=
owBite/CowBiteSpec.htm#REG_IE">REG_IE</a>
and <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_I=
ME">REG_IME</a>.
</p><h4><br>

<hr align=3D"CENTER">
<br>
Address: 0x4000134 - <a name=3D"REG_R"></a>REG_RCNT</h4>
<pre>               <font color=3D"#DD0000">*  * * * *  * * * *</font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#FF0099">M M</font><font color=3D"#BBBBBB"> X X  X X X </fon=
t><font color=3D"#DD0000">I</font><font color=3D"#BBBBBB">  </font><font co=
lor=3D"#008800">Q</font><font color=3D"#BBBBBB"> </font><font color=3D"#009=
9FF">P</font><font color=3D"#BBBBBB"> </font><font color=3D"#9900CC">O</fon=
t><font color=3D"#BBBBBB"> </font><font color=3D"#FF0099">N</font><font col=
or=3D"#BBBBBB">  </font><font color=3D"#008800">M</font><font color=3D"#BBB=
BBB"> </font><font color=3D"#0099FF">L</font><font color=3D"#BBBBBB"> </fon=
t><font color=3D"#9900CC">K</font><font color=3D"#BBBBBB"> </font><font col=
or=3D"#FF0099">J</font>

0 <font color=3D"#FF0099">(J)</font> =3D SC Data Bit (<font color=3D"#DD000=
0">* </font>GP Mode)
1 <font color=3D"#9900CC">(K)</font> =3D SD Data Bit (<font color=3D"#DD000=
0">* </font>GP Mode)
2 <font color=3D"#0099FF">(L)</font> =3D SI Data Bit (<font color=3D"#DD000=
0">* </font>GP Mode)
3 <font color=3D"#008800">(M)</font> =3D SO Data Bit (<font color=3D"#DD000=
0">* </font>GP Mode)

4 <font color=3D"#FF0099">(N)</font> =3D SC Direction (0 - Input, 1 - Outpu=
t) (<font color=3D"#DD0000">* </font>GP Mode)
5 <font color=3D"#9900CC">(O)</font> =3D SD Direction (0 - Input, 1 - Outpu=
t) (<font color=3D"#DD0000">* </font>GP Mode)
6 <font color=3D"#0099FF">(P)</font> =3D SI Direction (0 - Input, 1 - Outpu=
t) (<font color=3D"#DD0000">* </font>GP Mode)
7 <font color=3D"#008800">(Q)</font> =3D SO Direction (0 - Input, 1 - Outpu=
t) (<font color=3D"#DD0000">* </font>GP Mode)

8 <font color=3D"#FF3300">(I)</font> =3D Interrupt request enable. (<font c=
olor=3D"#DD0000">* </font>GP Mode) Interrupts can be requested when SI chan=
ges
        from HIGH to LOW, as General Purpose mode does not require a serial=
 shift clock,
        this interrupt may be produced even when the GBA is in Stop (low po=
wer standby)
        state.=20

E-F <font color=3D"#FF0099">(M)</font> =3D Mode selection
          0 X - Normal, Multiplayer, UART modes
          1 0 - General-Purpose Mode
          1 1 - JOY BUS Mode

<font size=3D"2" color=3D"#DD0000">*</font><font size=3D"2"> General Purpos=
e Mode Only</font></pre>
<p><br>
Thanks to Martin Korth for all the details about this register, found in hi=
s <a href=3D"http://www.work.de/nocash/gba.htm">no$gba</a>
documentation.<br>
<br>
The function of this register varies depending on the desired transfer mode=
. The mode bits should be initialized
before <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#RE=
G_SCCNT_L">REG_SCCNT_L</a>. In all modes
but General-Purpose mode, bits 0 - D go unused. In General-Purpose mode, th=
is register serves as a 4bit bi-directional
parallel port, directly controlling the individual SI,SO,SC, and SD pins. E=
ach can be separately declared as input
(with internal pull-up) or as output signal.
</p><h4>Address: 0x4000140 - <a name=3D"REG_JOYCNT"></a>REG_JOYCNT (JOY BUS=
 Control Register)</h4>
<pre>             =20
F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#FF0099">M M</font><font color=3D"#BBBBBB"> X X  X X X </fon=
t><font color=3D"#DD0000">I</font><font color=3D"#BBBBBB">  X X X X  X </fo=
nt><font color=3D"#0099FF">S</font><font color=3D"#BBBBBB"> </font><font co=
lor=3D"#9900CC">C</font><font color=3D"#BBBBBB"> </font><font color=3D"#FF0=
099">R</font>

0 <font color=3D"#FF0099">(R)</font> =3D Device Reset Flag (Command 0xFF)
1 <font color=3D"#9900CC">(C)</font> =3D Receive Complete Flag (Command 0x1=
4 or 0x15?)
2 <font color=3D"#0099FF">(S)</font> =3D Send Complete Flag (Command 0x14 o=
r 0x15?)
8 <font color=3D"#FF3300">(I)</font> =3D IRQ when receive a Device Reset Co=
mmand.</pre>
<p>Thanks to Martin Korth for all the details about this register, found in=
 his <a href=3D"http://www.work.de/nocash/gba.htm">no$gba</a>
documentation.<br>
<br>
Bits 0 - 1 of this register work similarly to the bits in <a href=3D"http:/=
/www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_IF">REG_IF</a>;
write a "1" to them to reset them and "acknowledge" that the incoming data =
was processed.<br>
<br>
<b>Address: 0x4000150 - <a name=3D"REG_JOYRE_L"></a>REG_JOYRE_L <br>
Address: 0x4000152 - <a name=3D"REG_JOYRE_H"></a>REG_JOYRE_H<br>
Address: 0x4000154 - <a name=3D"REG_JOYTR_L"></a>REG_JOYTR_L<br>
Address: 0x4000156 - <a name=3D"REG_JOYTR_H"></a>REG_JOYTR_H<br>
<br>
</b>These registers are used to send and recieve data in JOY BUS mode.
</p><h4>Address: 0x4000158 - <a name=3D"REG_JOYSTAT"></a>REG_JOYSTAT (JOY B=
US Receive Status Register)</h4>
<pre>             =20
F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#FF0099">M M</font><font color=3D"#BBBBBB"> X X  X X X X  X =
X </font><font color=3D"#008800">G G</font><font color=3D"#BBBBBB">  </font=
><font color=3D"#0099FF">S</font><font color=3D"#BBBBBB"> X </font><font co=
lor=3D"#FF0099">R</font> <font color=3D"#BBBBBB">X</font>

1 <font color=3D"#FF0099">  (R)</font> =3D Receive Status Flag (0 - Remove =
GBA is/was recieving)
3 <font color=3D"#0099FF">  (S)</font> =3D Send Status Flag (1 - Remot GBA =
is/was sending)
4-5 <font color=3D"#008800">(G)</font> =3D General use flag.  Not assigned =
for any specific purpose.</pre>
<p>Thanks to Martin Korth for all the details about this register, found in=
 his <a href=3D"http://www.work.de/nocash/gba.htm">no$gba</a>
documentation.<br>
<br>
Bit 1 of this register is automatically set when writing to <a href=3D"http=
://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_JOYTR_L">REG_JOYTR</=
a>,
and bit 3 is automatically reset when reading from <a href=3D"http://www.cs=
.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#REG_JOYRE_L">REG_JOYRE</a>.<br>
<br>
Possible commands received in JOY BUS mode (not possible to issue commands)=
:</p>
<pre></pre>
<p>
<table border=3D"0" cellpadding=3D"0" cellspacing=3D"0" width=3D"100%">
	<tbody><tr>
		<td width=3D"50%" valign=3D"TOP">
			<pre>Command FFh - Device Reset

  Receive FFh (Command)
  Send    00h (GBA Type number LSB (or MSB?))
  Send    04h (GBA Type number MSB (or LSB?))
  Send    XXh (lower 8bits of SIOSTAT register)



Command 00h - Type/Status Data Request

  Receive 00h (Command)
  Send    00h (GBA Type number LSB (or MSB?))
  Send    04h (GBA Type number MSB (or LSB?))
  Send    XXh (lower 8bits of SIOSTAT register)</pre>
		</td>
		<td width=3D"50%" valign=3D"TOP">
			<pre>Command 15h - GBA Data Write (to GBA)

  Receive 15h (Command)
  Receive XXh (Lower 8bits of JOY_RECV_L)
  Receive XXh (Upper 8bits of JOY_RECV_L)
  Receive XXh (Lower 8bits of JOY_RECV_H)
  Receive XXh (Upper 8bits of JOY_RECV_H)
  Send    XXh (lower 8bits of SIOSTAT register)

Command 14h - GBA Data Read (from GBA)

  Receive 14h (Command)
  Send    XXh (Lower 8bits of JOY_TRANS_L)
  Send    XXh (Upper 8bits of JOY_TRANS_L)
  Send    XXh (Lower 8bits of JOY_TRANS_H)
  Send    XXh (Upper 8bits of JOY_TRANS_H)
  Send    XXh (lower 8bits of SIOSTAT register)</pre>
		</td>
	</tr>
</tbody></table>
</p>
<p>
</p><hr align=3D"CENTER">

<h3><br>
Addresses 0x4000200 - 0x4000208 - <a name=3D"Interrupt Registers"></a>Inter=
rupt Registers</h3>
<p><b><br>
Address: 0x4000200 - <a name=3D"REG_IE"></a>REG_IE (Interrupt Enable Regist=
er)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X</font> <font color=3D"#008800">T </font><font c=
olor=3D"#0099FF">Y  </font><font color=3D"#9900CC">G </font><font color=3D"=
#FF0099">F </font><font color=3D"#FF3300">E </font><font color=3D"#008800">=
D  </font><font color=3D"#0099FF">S </font><font color=3D"#9900CC">L </font=
><font color=3D"#FF0099">K </font><font color=3D"#FF3300">J </font><font co=
lor=3D"#008800"> I </font><font color=3D"#0099FF">C </font><font color=3D"#=
9900CC">H </font><font color=3D"#FF0099">V</font>
</pre>
<pre>0 <font color=3D"#FF0099">(V)</font> =3D VBlank Interrupt=20
1 <font color=3D"#9900CC">(H)</font> =3D HBlank Interrupt=20
2 <font color=3D"#0099FF">(C)</font> =3D VCount Interrupt=20
3 <font color=3D"#008800">(I)</font> =3D Timer 0 Interrupt=20
4 <font color=3D"#FF3300">(J)</font> =3D Timer 1 Interrupt=20
5 <font color=3D"#FF0099">(K)</font> =3D Timer 2 Interrupt=20
6 <font color=3D"#9900CC">(L)</font> =3D Timer 3 Interrupt=20
7 <font color=3D"#0099FF">(S)</font> =3D Serial Communication Interrupt=20
8 <font color=3D"#008800">(D)</font> =3D DMA0 Interrupt=20
9 <font color=3D"#FF3300">(E)</font> =3D DMA1 Interrupt=20
A <font color=3D"#FF0099">(F)</font> =3D DMA2 Interrupt=20
B <font color=3D"#9900CC">(G)</font> =3D DMA3 Interrupt=20
C <font color=3D"#0099FF">(Y)</font> =3D Key Interrupt=20
D <font color=3D"#008800">(T)</font> =3D Cassette Interrupt </pre>
<p><br>
Use this register to mask out which interrupts are enabled or disabled. <br=
>
<br>
<b>Address: 0x4000202 - <a name=3D"REG_IF"></a>REG_IF (Interrupt Flags Regs=
ter)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X</font> <font color=3D"#008800">T </font><font c=
olor=3D"#0099FF">Y  </font><font color=3D"#9900CC">G </font><font color=3D"=
#FF0099">F </font><font color=3D"#FF3300">E </font><font color=3D"#008800">=
D  </font><font color=3D"#0099FF">S </font><font color=3D"#9900CC">L </font=
><font color=3D"#FF0099">K </font><font color=3D"#FF3300">J </font><font co=
lor=3D"#008800"> I </font><font color=3D"#0099FF">C </font><font color=3D"#=
9900CC">H </font><font color=3D"#FF0099">V</font>
</pre>
<pre>0 <font color=3D"#FF0099">(V)</font> =3D VBlank Interrupt=20
1 <font color=3D"#9900CC">(H)</font> =3D HBlank Interrupt=20
2 <font color=3D"#0099FF">(C)</font> =3D VCount Interrupt=20
3 <font color=3D"#008800">(I)</font> =3D Timer 0 Interrupt=20
4 <font color=3D"#FF3300">(J)</font> =3D Timer 1 Interrupt=20
5 <font color=3D"#FF0099">(K)</font> =3D Timer 2 Interrupt=20
6 <font color=3D"#9900CC">(L)</font> =3D Timer 3 Interrupt=20
7 <font color=3D"#0099FF">(S)</font> =3D Serial Communication Interrupt=20
8 <font color=3D"#008800">(D)</font> =3D DMA0 Interrupt=20
9 <font color=3D"#FF3300">(E)</font> =3D DMA1 Interrupt=20
A <font color=3D"#FF0099">(F)</font> =3D DMA2 Interrupt=20
B <font color=3D"#9900CC">(G)</font> =3D DMA3 Interrupt=20
C <font color=3D"#0099FF">(Y)</font> =3D Key Interrupt=20
D <font color=3D"#008800">(T)</font> =3D Cassette Interrupt </pre>
<p>This register will determine which interrupt is currently being serviced=
. When your interrupt service routine
get scalled, check these flags to determine what called it. In order to kee=
p yourself from servicing the wrong
interrupt at a later time, you should reset the flags to 0 by writing a 1 t=
o them. <br>
<br>
<br>
<b>Address: 0x4000204 - <a name=3D"REG_WS_CR"></a>REG_WSCNT (Wait State Con=
trol)</b></p>
<pre><font color=3D"#FF0000">R   </font>
F E D C  B A 9 8  7 6 5 4  3 2 1 0=20
<font color=3D"#FF3300">G</font> <font color=3D"#008800">P</font> <font col=
or=3D"#BBBBBB">X</font> <font color=3D"#0099FF">C  C</font> <font color=3D"=
#9900CC">N</font><font color=3D"#008800"> </font><font color=3D"#FF0099">M =
M</font><font color=3D"#CC0099"> </font><font color=3D"#0099FF"> </font><fo=
nt color=3D"#FF3300">L</font><font color=3D"#0099FF"> </font><font color=3D=
"#008800">K K</font> <font color=3D"#0099FF">J</font><font color=3D"#9900CC=
">  I I</font> <font color=3D"#FF0099">S S</font></pre>
<pre>0-1 <font color=3D"#FF0099">(S)</font> =3D <a href=3D"http://www.cs.ri=
t.edu/~tjh8300/CowBite/CowBiteSpec.htm#CART%20RAM">SRAM</a> wait state
          00:  4 cycles          01:  3 cycles
          10:  2 cycles          11:  8 cycles
2-3 <font color=3D"#9900CC">(I)</font> =3D <a href=3D"http://www.cs.rit.edu=
/~tjh8300/CowBite/CowBiteSpec.htm#GAME%20PAK%20ROM">Bank 0x08000000</a> ini=
tial wait state
          00: 4 cycles           01: 3 cycles
          10: 2 cycles           11: 8 cycles
4   <font color=3D"#0099FF">(J)</font> =3D Bank 0x08000000 subsequent wait =
state
          0: _2_ cycles  1: 1 cycle
5-6 <font color=3D"#008800">(K)</font> =3D <a href=3D"http://www.cs.rit.edu=
/~tjh8300/CowBite/CowBiteSpec.htm#ROM%20IMAGE%201">Bank 0x0A000000</a> init=
ial wait state
          00: 4 cycles           01: 3 cycles
          10: 2 cycles           11: 8 cycles
7   <font color=3D"#FF3300">(L)</font> =3D Bank 0x0A000000 subsequent wait =
state
          0: _4_ cycles  1: 1 cycle
8-9 <font color=3D"#FF0099">(M)</font> =3D <a href=3D"http://www.cs.rit.edu=
/~tjh8300/CowBite/CowBiteSpec.htm#ROM%20IMAGE%202">Bank 0x0C000000</a> init=
ial wait state
          00: 4 cycles           01: 3 cycles
          10: 2 cycles           11: 8 cycles
A   <font color=3D"#9900CC">(N)</font> =3D Bank 0x0C000000 subsequent wait =
state
          0: _8_ cycles          1: 1 cycle
B-C <font color=3D"#0099FF">(C)</font> =3D Cart clock.  Don't touch.
          00:  Terminal output clock fixed lo
          01:  4 Mhz
          10:  8 Mhz
          11:  16 Mhz
E   <font color=3D"#008800">(P)</font> =3D Prefetch.  When enabled, the GBA=
 attempts to read opcodes from ROM
          when the CPU is not using the bus.  The 8-word-by-16-bit prefetch
          buffer makes subsequent ROM reads faster (0 waits) in code that
          accesses both ROM and RAM. =20
          0: Disable (and save battery power)
          1: Enable
F   <font color=3D"#FF3300">(G)</font> =3D Game Pak type
          0: AGB multiplexed bus
          1: DMG/CGB bus
</pre>
<p>Use this register to control wait state settings and the prefetch buffer=
 for ROM and SRAM. Thanks to <a href=3D"http://pineight.com/contact/">Damia=
n
Yerrick</a> for contributing this info, and for pointing me to some relevan=
t reading material.<br>
<br>
<br>
<b><br>
Address: 0x4000208 - <a name=3D"REG_IME"></a>REG_IME (Interrupt Master Enab=
le)</b></p>
<pre>7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X</font> <font color=3D"#FF0099">M</fo=
nt>=20
</pre>
<pre>0 <font color=3D"#FF0099">(M)</font> =3D Master interrupt enable. When=
 off, all interrupts are disabled.  This
        must be on for the interrupt bits in <a href=3D"http://www.cs.rit.e=
du/~tjh8300/CowBite/CowBiteSpec.htm#REG_IE">REG_IE</a> to have any effect.<=
/pre>
<p><br>
<br>

</p><hr align=3D"CENTER">
<br>
<b><br>
Address: 0x4000300 - <a name=3D"REG_PAUSE"></a>REG_HALTCNT_L (First Boot/De=
bug Control - Unimplemented in CowBite)</b><p></p>
<p>
</p><pre>7 6 5 4  3 2 1 0=20
<font color=3D"#BBBBBB">X X X X  X X X </font><font color=3D"#FF0099">F</fo=
nt></pre>
<pre>0 <font color=3D"#FF0099">(F)</font> =3D First Boot Flag (0 =3D First,=
 1 =3D Further)
</pre>
<p>Thanks to Martin Korth for the details of this register. The following c=
omes from his description in the <a href=3D"http://www.work.de/nocash/gba.h=
tm">no$gba</a> documentation.<br>
<br>
After initial reset, the GBA BIOS initializes the register to 0x1, and any =
further execution of the Reset vector
(0x00000000) will pass control to the Debug vector (0x0000001C) when sensin=
g the register to be still set to 0x1.
Normally the debug handler rejects control unless it detects Debug flags in=
 cartridge header, in that case it may
redirect to a cut-down boot procedure (bypassing Nintendo logo and boot del=
ays). <br>
<br>
<br>
<b><br>
Address: 0x4000301 - <a name=3D"REG_HALTCNT_H"></a>REG_HALTCNT_H (Low Power=
 Mode Control - Unimplemented in CowBite)</b></p>
<pre>7 6 5 4  3 2 1 0=20
<font color=3D"#FF0099">M </font><font color=3D"#BBBBBB">X X X  X X X X </f=
ont></pre>
<pre>7 <font color=3D"#FF0099">(M)</font> =3D Power Down Mode (0 =3D Halt, =
1 =3D Stop)
</pre>
<p>Thanks to Martin Korth for the details of this register. The following c=
omes from his description in the <a href=3D"http://www.work.de/nocash/gba.h=
tm">no$gba</a> documentation.<br>
<br>
In Halt mode, the CPU is paused until an interrupt occurs, this should be u=
sed to reduce power-consumption during
periods when the CPU is waiting for interrupt events. In Stop mode, most of=
 the hardware including sound and video
are paused, this very-low-power mode could be used much like a screensaver.=
<br>
<br>
The current GBA BIOS addresses only the upper eight bits of this register (=
by writing 0x00 or 0x80 to address 0x04000301),
however, as the register isn't officially documented, some or all of the bi=
ts might have different meanings in
future GBA models. For best forwards compatibility, it'd generally be more =
recommended to use the BIOS Functions
SWI 2 (Halt) or SWI 3 (Stop) rather than writing to this register directly.=
<br>
<br>
<br>
<b><br>
Address: 0x4000800 - <a name=3D"REG_IMC_L"></a>REG_IMC_L (Internal Memory C=
ontrol - Unimplemented in CowBite)</b></p>
<pre>	=09
F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X X X X  X X X X  X X</font> <font color=3D"#FF3300=
">M</font> <font color=3D"#BBBBBB">X</font>  <font color=3D"#008800">L</fon=
t> <font color=3D"#0099FF">K</font> <font color=3D"#9900CC">J</font> <font =
color=3D"#FF0099">I
			=09
</font>0 <font color=3D"#FF0099">(I)</font> =3D Purpose unkown.  When set, =
locks the GBA or sets the top-left
        tile number to 0x82.
1 <font color=3D"#9900CC">(J)</font> =3D Unknown.
2 <font color=3D"#0099FF">(K)</font> =3D Unknown.
3 <font color=3D"#008800">(L)</font> =3D Unkown.
5 <font color=3D"#FF3300">(M)</font> =3D When unset this locks up the GBA o=
r just disallows VRAM changes
        (but can be used<font color=3D"#FF0099"> </font>simulteneously with=
 bit 0).  It is set by default.
</pre>
<p>This register is undocumented even for official developers. What little =
we know about this it comes separately
from Martin Korth's no$gba documentaion and gbcft's experimentations. gbcft=
 comments that he did his testing a
while back and is unsure about his assessment of bits 0 and 5. Anybody who =
knows about it can feel free to <a href=3D"mailto:SorcererXIII@yahoo.com">e=
mail
</a>me with more info. <font color=3D"#FF0099"><br>
<br>
</font>This register (the whole 32-bit word, including REG_IMC_H) is mirror=
ed at intervals of 0x10000 bytes in
IORAM (it is the only IORAM<br>
register that is mirrored in in this way). <br>
<br>
<b><br>
Address: 0x4000802 - <a name=3D"REG_IMC_L"></a>REG_IMC_H (Internal Memory C=
ontrol - Unimplemented in CowBite)</b></p>
<pre>F E D C  B A 9 8  7 6 5 4  3 2 1 0
<font color=3D"#BBBBBB">X X X X  </font><font color=3D"#FF0099">W W W W</fo=
nt>  <font color=3D"#BBBBBB">X X</font> <font color=3D"#BBBBBB">X</font> <f=
ont color=3D"#BBBBBB">X</font>  <font color=3D"#BBBBBB">X X X X  </font>

8 - B <font color=3D"#FF0099">(W)</font>=3D WRAM Wait state control.
           1101 - 2 Waitstates (3/3/6 cycles 8/16/32bit accesses)
           1110 - 1 Waitstate (2/2/4 cycles for 8/16/32bit acceses)

           Default setting appears to be 1101.  A value of 1111 causes the
           system to lock up.
</pre>
<p>Thanks to Martin Korth for detailing the function of this registers in h=
is <a href=3D"http://www.work.de/nocash/gba.htm">no$gba</a>
documentation. Note that the benefits of this register are not guaranteed t=
o work on all GBAs and may very well
have undesirable results if tampered with! In other words, if you use this =
register at all, do so in your own private
tests.
</p><h2><br>

<hr align=3D"CENTER">
<br>
11. <a name=3D"Miscellaneous"></a>Miscellaneous/Weirdness</h2>
<p>This is a new section devoted any interesting little tidbits that don't =
quite fit in anywhere else. I'm starting
it off with . . .
</p><h3><br>
Unknown Registers</h3>
<p>These are registers that I don't know the function of. Gradually their n=
umbers have dwindled down to almost
nothing.While most aren't even readable, certain ones seem to be writeable.=
 I have an idea of what some of them
are based on the headers included with many open source demos, but as to th=
eir specific function, I have no idea.
Let me know if you find out what purpose they serve, if any, and I will put=
 your notes here (and of course give
credit).</p>
<pre>0x002:         REG_DISPCNT_H - Writing to bit 0 will cause (horizontal=
ly)
               adjacent pairs of pixels to have their green component
               swapped. What good is this for?  Anybody know?

0x04E:         REG_MOSAIC_H - Unreadable (gobbledygook)
0x056 - 0x05E:	Unreadable (gobbledygook)
0x066:         REG_SOUND1CNT_X (high 16 bits) Unreadable (0x0000)
0x06A:         REG_SOUND2CNT_L (high 16 bits) Unreadable (0x0000)
0x06E:         REG_SOUND2CNT_H (high 16 bits) Unreadable (0x0000)
0x076:         REG_SOUND3CNT_X (high 16 bits) Unreadable (0x0000)
0x07A:         REG_SOUND4CNT_L (high 16 bits) Unreadable (0x0000)
0x07E:         REG_SOUND4CNT_L (high 16 bits) Unreadable (0x0000)
0x086:         REG_SOUNDCNT_X (high 16 bits) Unreadable (0x0000)
0x08A:         REG_SOUNDBIAS (high 16 bits) Unreadable (0x0000)
0x08C:         Unreadable (gobbledygook)
0x08E:         Unreadable (gobbledygook)
0x0A8 - 0xAE:  Unreadable (gobbledygook)
0x0E0 - 0x0FE: Unreadable (gobbledygook)
0x110 - 0x11E: Unreadable (gobbledygook)
0x12C:         Unreadable (gobbledygook)
0x12E:         Unreadable (gobbledygook)
0x136:         REG_IR (high 16 bits) Unreadable (0x0000). =20
               Served as the Infrared register on prototypes.
0x138 - 13E:   Unreadable (gobbledygook)
0x142:         Unreadable (0x0000)
0x144-14E:     Unreadable (gobbledygook)
0x15A:         JOYSTAT_H - Unreadable (0x0000)
0x15C - 0x1FE: Unreadable (gobbledygook)
0x206:         REG_WSCNT (high 16 bits) Unreadable (0x0000)
0x20A:         REG_IME (high 16 bits) Unreadable (0x0000)
0x20C - 0x2FE: Unreadable (gobbledygook)
0x302:         REG_PAUSE (high 16 bits) Unreadable (0x0000)
0x304 - 0x3FE: Unreadable (gobbledygook)
0x410:         Martin Korth has observed that the BIOS writes 0xFF (8 bit) =
to this address on startup.

</pre>
<p>I have noted that some of these registers always read as a certain repea=
ting gobbledygook value no matter what
is written to them (I take this to be of the same origin as the gobbledygoo=
k that comes from reading BIOS -- see
<a href=3D"http://www.devrs.com/gba">Jeff Frohwein's</a> GBA FAQ), but some=
 always read 0. For the most part these
seem to be the "high" 16 bits of registers we already know the function of =
(thanks gbcft for pointing
out what probably should have been obvious to me). Others are registers tha=
t probably do something, but I just
don't know what. They may read as something other than 0 if the conditions =
are right.<br>
<br>
<b>Possibilities:</b><br>
The following are some suggested possiblities for what the unkown registers=
 could be (thanks goes out to Kay for
this), based on what Nintendo has included in previous hardware:<br>
<br>
SPR_TIME_OVER bit: sprite blit time out register (1 bit). This bit is set w=
hen sprite processing overloads during
HDraw<br>
SPR_RANGE_OVER bit: displayed objects number (regardless of the size) becom=
es or is greater than maximum GFX ASIC
is able to process<br>
xxxx_VER_NUMBER reg: regsiter containing the xxxx IC version number (usuall=
y bit 0 to 3 if made by Nintendo)<br>
<br>
- Martin Korth notes that there also appears to be an undocumented register=
 that is used to mask out cartridge
memory (except first 4KBytes of ROM) in Single Game Pak slave mode . .. <br=
>
<br>
- Like all Nintendo hardware designs, the GBA may have one or more 8/16 bit=
 in/out parallel data ports mapped at
the bottom of I/O addresses.
</p><h2>12. <a name=3D"Links"></a>Links</h2>
<p>The following are links to other documents which should prove useful to =
GBA developers:<br>
<br>
<a href=3D"http://www.gbadev.org/">http://www.gbadev.org/</a> (A great reso=
urce for GBA developers)<br>
<a href=3D"http://www.devrs.com/gba/">Devrs.com GBA Site</a> (Another great=
 resource, maintained by Jeff Frohwein)<br>
<a href=3D"http://www.devrs.com/gba/files/gbadevfaqs.php">Jeff Frohwein's G=
BA Dev FAQ</a><br>
<a href=3D"http://216.167.73.47/~dovoto/">The Pern Project</a> (Tutorials f=
or GBA development)<br>
<a href=3D"http://www.bottledlight.com/docs/sdk.html">Mappy SDK</a> (A docu=
ment similar to this one but for Joat's
<a href=3D"http://www.bottledlight.com/">Mappy</a> emulator)<br>
<a href=3D"http://www.arm.com/arm/TRMs?OpenDocument">ARM's Technical Refere=
nce Manuals</a> (Docs that you should
have around if you want to understand the ARM processor)<br>
<a href=3D"http://belogic.com/gba/">The Audio Advance</a> (A great site by =
Uze explaining the GBA's sound system)
<br>
<a href=3D"http://members.truepath.com/AndrewMay/GBA.html">Andrew May's sit=
e</a> (Technical info on the GBA link
port)<br>
<a href=3D"http://cowbite.emuunlim.com/index.php"><br>
CowBite</a> (The emulator I've been writing off and on. Make sure you check=
 it out and <a href=3D"mailto:SorcererXIII@yahoo.com">give
me feedback</a>!)<br>
<a href=3D"http://www.work.de/nocash/gba.htm">no$gba</a> (A good asm debugg=
er/emulator for commercial developers
with VERY good documentation on the GBA hardware. Free version of no$gba is=
 compatible with multiboot games.)<a href=3D"http://www.bottledlight.com/">=
<br>
Mappy</a> (A great emulator for asm debugging and graphical feedback on spr=
ites, backgrounds, etc.)<br>
<a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/Mappy%20(A%20great%20emul=
ator%20for%20developers)Visual%20Boy%20Advance%20(A%20very%20accurate%20emu=
lator%20that%20is%20gdb%20compatible)">Visual
Boy Advance</a> (A very accurate emulator that is gdb compatible)
</p><h2><br>
13. <a name=3D"Thanks"></a>Thanks</h2>
<p><br>
<b>The following are individuals who contributed info or corrections to thi=
s document. Thanks guys!<br>
</b><br>
Agent Q (Wrote the original spec, version 1.0)<br>
Uze (All of the sound register info comes directly from his <a href=3D"http=
://belogic.com/gba/">Audio Advance</a>
site)<br>
Martin Korth (Author <a href=3D"http://www.work.de/nocash/gba.htm">no$gba</=
a> of who has given me permission to consolidate
additional info from his emulator's informative help documents with this on=
e, most particularly serial registers,
some BIOS functions, and undocumented registers.)<br>
Forgotten (VBA Author. Many of the BIOS call descriptions come from his <a =
href=3D"http://vboy.emuhq.com/faq.shtml">Visual
Boy Advance FAQ</a>.<br>
gbcft (LOTS of info on interrupts, windowing, memory mirrors, the "Unkown R=
egisters" section; helped
me debug a lot of errors in the emulator, and offered many corrections, inf=
o, and suggestions).<a href=3D"http://pineight.com/contact/"><br>
</a>Kay (Contributed memory port sizes and wait states, DMA cycle timings, =
info regarding the BIOS, and various
advice, testing, and expertise regarding the GBA and older console systems)=
<a href=3D"http://pineight.com/contact/"><br>
Damian Yerrick</a> (Contributed the WSCOUNT register)<br>
Markus (Actually I asked him for help with LZSS. Also, his gfx2gba tool has=
 proven <i>extremely</i> helpful in
my non-CowBite projects.:)<br>
ePac (Gave me links to serial info and did a nice writeup about it in the g=
badev group)<br>
Costis (A variety of new info/corrections)<br>
Grauw (Info on forced blanking, hblank lenghths, and on the BIOS wait funct=
ion.)<br>
Max<br>
Otaku<br>
Ped (Pointed out errors in the memory ranges, DISPCNT bit 5, and a bad typo=
 regarding rotates/scale backgrounds).<br>
Yarpen (Almost all the information on the timer registers and the keyboard =
control register. Thanks!)<br>
<br>
<b><br>
General Thanks</b><br>
<br>
All those GBA demo authors. You rock!<br>
Every other emu author<br>
<a href=3D"http://www.gbadev.org/">http://www.gbadev.org/</a><br>
The gbadev list on yahoo<br>
SimonB and all the others who run/moderate the above sites<br>
Dovoto and the <a href=3D"http://216.167.73.47/~dovoto/">PERN Project</a><b=
r>
Jeff Frohwein and his <a href=3D"http://www.devrs.com/gba">Devrs.com</a> si=
te<br>
Nocturn and his tutorials<br>
Uze from <a href=3D"http://belogic.com/gba/">BeLogic</a> for all the great =
information on the GBA's sound!<br>
Andrew May for his site on GBA serial data<br>
Nintendo <br>
<br>
If I've forgotten to list your name or an important resource in this sectio=
n, <a href=3D"http://www.cs.rit.edu/~tjh8300/CowBite/SorcererXIII@yahoo.com=
">let
me know</a>.</p>
<p align=3D"CENTER"><font size=3D"2">This document and its author are in no=
 way associated with, endorsed or supported
by<br>
Nintendo. GBA and Game Boy Advance are registered trademarks of Nintendo.<b=
r>
The CowBite emulator itself is copyright 2002 Thomas Happ</font>



</p></body></html>
------MultipartBoundary--zeeJfYrDhIOf5DTTzQx4dFZQdEPfC9gTLoRmLB1V2w------
